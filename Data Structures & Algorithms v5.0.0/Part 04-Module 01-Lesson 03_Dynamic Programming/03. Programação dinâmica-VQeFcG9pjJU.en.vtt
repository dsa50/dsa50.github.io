WEBVTT
Kind: captions
Language: en

00:00:00.380 --> 00:00:04.560
The knapsack problem shows the beauty of
a technique called dynamic programming.

00:00:05.840 --> 00:00:10.850
With dynamic programming, you can make a
really complicated problem like this one

00:00:10.850 --> 00:00:14.629
run much faster by breaking
it into subproblems.

00:00:14.630 --> 00:00:19.300
Here, the subproblem was finding
the answer for a smaller weight.

00:00:19.300 --> 00:00:24.235
You begin by solving for something
like a base case, a subproblem so

00:00:24.235 --> 00:00:28.819
small that the answer is very simple or
trivial to compute.

00:00:28.819 --> 00:00:31.290
We started with one object.

00:00:31.290 --> 00:00:35.103
With only one thing to consider,
finding the maximum possible value for

00:00:35.103 --> 00:00:37.230
any weight was simple.

00:00:37.230 --> 00:00:41.809
Another common feature of a dynamic
programming solution is a lookup table

00:00:41.810 --> 00:00:43.990
that stores solutions to subproblems.

00:00:45.200 --> 00:00:47.160
We stored the maximum values for

00:00:47.160 --> 00:00:49.830
different weight limits
in our lookup table.

00:00:49.830 --> 00:00:54.810
Dynamic programming solutions take
advantage of these two things, solving

00:00:54.810 --> 00:00:59.390
the problem for a trivial case and
storing the solution in a lookup table,

00:00:59.390 --> 00:01:03.350
by using them to slowly add
complexity to a problem.

00:01:03.350 --> 00:01:07.390
Another feature of a dynamic
programming solution is an equation

00:01:07.390 --> 00:01:09.700
used at each step as you add complexity.

00:01:11.590 --> 00:01:14.990
For us,
the equation looks something like this.

00:01:15.500 --> 00:01:20.110
The equation often combines some values
previously computed in the lookup table,

00:01:21.210 --> 00:01:25.490
sometimes with each other and
sometimes with a new value you introduce

00:01:25.490 --> 00:01:27.800
like the value of whatever
object you're looking at.

00:01:28.840 --> 00:01:33.370
We used the values already stored in
the table as we added new objects,

00:01:33.370 --> 00:01:36.260
a technique often called memoization.

00:01:36.260 --> 00:01:39.360
So we ultimately didn't need
to recompute them every time.

00:01:40.560 --> 00:01:43.611
This is the hidden power
of dynamic programming.

00:01:43.611 --> 00:01:47.192
You compute and
save solutions to smaller problems.

00:01:47.192 --> 00:01:50.429
Then you don't need to calculate them
again for more complex problems.

00:01:51.760 --> 00:01:53.830
It might seem like a simple idea, but

00:01:53.830 --> 00:01:57.340
it can have a really powerful effect
on efficiency if it's done well.

00:01:58.380 --> 00:02:02.369
One of the most useful skills to have
when going into a technical interview

00:02:02.370 --> 00:02:06.350
is the ability to spot a problem that
has a dynamic programming solution.

00:02:07.490 --> 00:02:09.630
It didn't come naturally to me at first,
but

00:02:09.630 --> 00:02:13.720
after practicing by trying to solve a
bunch of dynamic programming problems on

00:02:13.720 --> 00:02:16.730
my own, I started to get the hang of it.

00:02:16.730 --> 00:02:19.630
One thing you need to look out for
is a complicated problem

00:02:19.630 --> 00:02:24.400
that seems to require trying every
combination to find the solution.

00:02:24.400 --> 00:02:28.929
You need to ask yourself, can I
break this problem into subproblems?

00:02:28.930 --> 00:02:30.390
If the answer is yes,

00:02:30.390 --> 00:02:33.590
then you've got a problem with
a dynamic programming solution.

