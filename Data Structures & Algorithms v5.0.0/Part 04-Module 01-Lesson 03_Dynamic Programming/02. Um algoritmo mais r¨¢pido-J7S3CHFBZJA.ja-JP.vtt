WEBVTT
Kind: captions
Language: ja-JP

00:00:00.710 --> 00:00:02.500
もっとスマートなアプローチについて説明しましょう。

00:00:03.600 --> 00:00:07.345
最初の目標は
考えられる最大の重さの値を

00:00:07.345 --> 00:00:09.422
最大化することである必要はありません。

00:00:09.422 --> 00:00:13.905
考えられる最小の重さの値の最大化を
試行したらどうなるでしょうか。

00:00:13.905 --> 00:00:17.823
そして最大の重さになるまで
それらを合計し続けます。

00:00:17.823 --> 00:00:20.120
例を見てみましょう。

00:00:20.120 --> 00:00:24.260
まずは配列を作成します。
これを使って重量上限の範囲内で

00:00:24.260 --> 00:00:27.100
それぞれの重さを
考えられる最大値として保存します。

00:00:28.150 --> 00:00:31.470
重量は
すべて正の整数になり

00:00:31.470 --> 00:00:34.890
配列のインデックスは
重さを表すと想定します。

00:00:35.180 --> 00:00:37.600
ここでは、まずゼロから
始めます。

00:00:38.200 --> 00:00:41.960
これらのオブジェクトは
重量上限が 6 のナップザックへの

00:00:41.960 --> 00:00:42.600
適合を試行しています。

00:00:43.690 --> 00:00:45.790
重量 2 のオブジェクトを
とりあげます。

00:00:46.990 --> 00:00:50.810
インデックス 2 の値を
オブジェクトの値に更新できます。

00:00:52.230 --> 00:00:55.180
そして同じ値を使用して
それ以降のすべてを更新します。

00:00:56.350 --> 00:01:00.390
ナップサックが重量 6 を保持できたとしても
オブジェクトは 1 つしか見えないので

00:01:00.390 --> 00:01:04.550
その 1 つのオブジェクトからの
最善の値をベースにする必要があります。

00:01:05.680 --> 00:01:07.660
次のオブジェクトを見てみます。

00:01:07.660 --> 00:01:10.585
インデックス 5 まで
何も変更できません。

00:01:10.585 --> 00:01:14.934
このオブジェクトの値は
最大値より大きく

00:01:14.935 --> 00:01:17.150
全体の重量を占めています。

00:01:17.150 --> 00:01:19.995
ですから重さ 5 と 6 の
最大値を置換します。

00:01:19.995 --> 00:01:26.750
最後のオブジェクトについては、まず
変更可能な点はインデックス 4 です。

00:01:26.750 --> 00:01:29.235
この値はそれよりも小さいので
このままにしておきます。

00:01:30.510 --> 00:01:35.890
インデックス 5 を見てそれをインデックス 1 の値を
加えた値と比較します。

00:01:35.890 --> 00:01:40.288
古い値のほうが大きいため
そのままにしておきます。

00:01:40.288 --> 00:01:45.540
インデックス 6 でオブジェクト値を
インデックス 2 の値に加えると

00:01:45.550 --> 00:01:50.480
より大きな値になるので
これを置換します。

00:01:50.480 --> 00:01:52.620
これで問題は解決しました。

00:01:52.620 --> 00:01:56.700
この例の小さな値では
不要に思えるかもしれませんが、

00:01:56.700 --> 00:01:59.910
多数のブジェクトの場合
どれだけの時間が節約できるでしょうか。

00:01:59.910 --> 00:02:02.500
ここではテーブルを利用して
事前計算済みの

00:02:02.500 --> 00:02:04.360
最大値を格納しています。

00:02:05.430 --> 00:02:08.449
よってこれらの数値を取得するために
必要なものはこの作業だけです。

00:02:09.600 --> 00:02:14.220
すべてのオブジェクトを試行し
重量上限の範囲内で考えられる

00:02:14.220 --> 00:02:16.880
それぞれの重さの最大値
が増加できるかどうかを確認します。

00:02:18.130 --> 00:02:22.650
よってランタイムは n 掛ける W
ここでの W は

00:02:22.650 --> 00:02:25.919
ナップサックの重量上限で
n は要素の数です。

00:02:27.140 --> 00:02:30.640
これは疑似多項式
時間ソリューションです。

00:02:30.640 --> 00:02:34.459
真の多項式ランタイムは
n 以外に変数を持ちません。

00:02:35.870 --> 00:02:40.120
繰り返しますが、大きな数に対しては
多項式時間アルゴリズムは

00:02:40.120 --> 00:02:43.140
指数時間アルゴリズムより
スピーディーです。

00:02:43.140 --> 00:02:45.339
よってこのソリューションは
迅速だと言えます。

