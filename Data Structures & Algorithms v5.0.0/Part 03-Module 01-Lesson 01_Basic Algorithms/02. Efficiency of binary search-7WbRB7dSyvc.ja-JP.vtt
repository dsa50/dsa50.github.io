WEBVTT
Kind: captions
Language: ja-JP

00:00:00.400 --> 00:00:04.300
では、新しい例を使ってこのアルゴリズムの
効率について検証してみましょう

00:00:05.460 --> 00:00:08.610
ここに 8 つの要素を持つ配列があり
これに 10 という値が含まれているか

00:00:08.610 --> 00:00:09.490
どうか確認するとします

00:00:10.990 --> 00:00:12.874
このとき
まず中央から開始しますが

00:00:12.874 --> 00:00:16.508
この例では配列に含まれる
要素の数が偶数なので

00:00:16.508 --> 00:00:17.855
少し面倒なことになります

00:00:17.855 --> 00:00:20.630
この場合、4 または 5 から
チェックを開始します

00:00:20.630 --> 00:00:24.982
アルゴリズムを設計する際には
この例のように真の中央がない場合に

00:00:24.982 --> 00:00:27.788
低い方あるいは
高い方のどちらから

00:00:27.789 --> 00:00:31.880
チェックを始めるか決めて
おかなければなりません

00:00:33.500 --> 00:00:35.180
ここでは低い方から
開始することにして

00:00:35.180 --> 00:00:36.150
まず 4 を見てみます

00:00:37.200 --> 00:00:39.920
先ほどと同様に探している値が
中央にある値より大きいか

00:00:39.920 --> 00:00:41.410
小さいかを判断します

00:00:42.430 --> 00:00:44.700
この場合は中央よりも大きいので

00:00:44.700 --> 00:00:46.300
配列の後半部分だけチェックすれば
よいことになります

00:00:47.890 --> 00:00:50.610
前述のとおり、この配列に含まれる
要素の数は偶数なので

00:00:50.610 --> 00:00:54.425
中央にある 2 つの数値のうち左側の数値を選び
ここからチェックを開始します

00:00:54.425 --> 00:00:57.625
10 は 6 より大きく配列の後半に

00:00:57.625 --> 00:01:00.645
あるはずなので、この後半部分をさらに
2 分割して後半の値を見ます

00:01:01.675 --> 00:01:04.175
後半部分にある要素の数も
偶数のため、低い方の値を中央として

00:01:04.175 --> 00:01:07.440
値をチェックします

00:01:07.440 --> 00:01:10.500
10 は中央にある要素 7 よりも
大きいため、後半部分をチェック

00:01:10.500 --> 00:01:12.850
することになりますが
残りの要素は 1 つしかありません

00:01:12.850 --> 00:01:16.700
この配列に含まれる最大の要素をチェックした結果
目的の数値はこの要素よりも大きいことが判明し

00:01:16.700 --> 00:01:19.690
10 はこの配列に含まれないと
結論づけることができます

00:01:20.770 --> 00:01:24.610
時間効率は必要なステップの
数によって決まるもので

00:01:24.610 --> 00:01:28.275
1 つひとつの反復を追跡することが
解決に役立ちます

00:01:28.275 --> 00:01:31.705
各要素を 1 つひとつチェックするのは
効率が悪いので

00:01:31.705 --> 00:01:36.334
配列を半分に分割して
特定の要素のみを考慮します

00:01:36.334 --> 00:01:41.910
この方法なら実行時間が O(n) まで
長くなることはありません

00:01:41.910 --> 00:01:44.580
配列の長さとアルゴリズムの反復を
わかりやすくするために

00:01:44.580 --> 00:01:48.120
このような表を
作成しました

00:01:49.470 --> 00:01:52.910
ご覧いただいたとおり
長さが 8 の場合は

00:01:52.910 --> 00:01:54.679
アルゴリズムを 4 回繰り返します

00:01:54.680 --> 00:01:56.387
もちろん、これは
最悪の場合です

00:01:56.387 --> 00:02:00.400
各要素の間や配列の外側に
数値を配置してみて

00:02:00.400 --> 00:02:03.390
最悪の場合に必要な
反復回数を割り出すこともできます

00:02:03.390 --> 00:02:07.310
時間節約のため、ビデオ撮影の前に
この作業をしておきました

00:02:07.310 --> 00:02:10.199
その過程であるトリックに
気付いたのです

00:02:10.199 --> 00:02:13.400
最悪の場合をチェックする際
その配列に含まれる

00:02:13.400 --> 00:02:17.900
最も大きな値を選びます

00:02:17.900 --> 00:02:21.900
真の中央がない場合は
必ず低い方の要素を選択します

00:02:21.900 --> 00:02:24.590
これで本当にうまくいくかは各自で
確認してもらう必要がありますが

00:02:24.590 --> 00:02:26.480
ここではこのメソッドが正しいと想定します

00:02:26.480 --> 00:02:31.480
配列の長さが 8 であれば
反復回数は最悪の場合で 4 となります

00:02:31.480 --> 00:02:33.804
最初の例から
結果を得ることもできます

00:02:33.804 --> 00:02:38.880
配列の長さが 7 の場合は
ステップを 3 回繰り返しました

00:02:38.880 --> 00:02:41.954
では、他の長さでは
どうなるでしょうか

00:02:41.955 --> 00:02:46.462
配列の長さが 1 で
30 という値を探しているとします

00:02:46.462 --> 00:02:50.899
この場合、配列に目的の値が含まれるかどうか
確認する作業は

00:02:50.900 --> 00:02:52.580
1 回のステップで済みますね

00:02:52.580 --> 00:02:54.880
よって、表に 1 と記入します

00:02:54.880 --> 00:02:57.840
では、配列の長さが 2 で
23 という値を探している場合は

00:02:57.840 --> 00:03:00.200
どうなるでしょうか

00:03:00.200 --> 00:03:02.710
ここでも先ほどの
トリックを実践します

00:03:02.710 --> 00:03:05.900
この例では配列に含まれる要素よりも
大きな数値を選びました

00:03:05.900 --> 00:03:09.870
要素の数が偶数で中央がない場合は
必ず低い方を選択します

00:03:09.870 --> 00:03:12.340
配列に 11 の要素が
含まれるとしたら

00:03:12.340 --> 00:03:14.510
中央の左側にある数字を
選びます

00:03:15.780 --> 00:03:18.480
23 は 18 より大きいので
次は 21 をチェックします

00:03:19.690 --> 00:03:23.579
このように、わずか 2 回で
この配列には 23 がないことがわかりました

00:03:24.610 --> 00:03:26.980
よって、表には 2 と記入します

00:03:26.980 --> 00:03:30.709
時間の都合上、残りの例については
省くことにしますが

00:03:30.710 --> 00:03:33.230
本当にこれらの結果が
正しいかどうかは

00:03:33.230 --> 00:03:34.179
各自で確認してください

00:03:35.425 --> 00:03:38.800
では、次にこの効率の
全体像を把握したいと思います

00:03:39.250 --> 00:03:41.490
4 は 8 の 1/2 なので

00:03:41.490 --> 00:03:44.630
もしかすると効率は
配列の長さの 1/2 なのかもしれません

00:03:44.630 --> 00:03:46.780
もちろん、これは単なる
概算に過ぎません

00:03:47.880 --> 00:03:51.400
アルゴリズムにおけるステップの合計数を
数えるのではなく

00:03:51.400 --> 00:03:54.670
単にアルゴリズムの実行回数を
数えることにします

00:03:54.670 --> 00:03:56.850
この例では n が 8 のときは 4 になります

00:03:57.850 --> 00:04:01.810
しかし、2 の 1/2 は 2 ではなく
1 の 1/2 は 1 ではないので、この仮説が正しいか

00:04:01.810 --> 00:04:03.780
どうか怪しくなってきました

00:04:03.780 --> 00:04:05.320
残念です

00:04:05.320 --> 00:04:09.359
アルゴリズムを実行するたびに
配列を 2 分割しているので

00:04:09.360 --> 00:04:12.870
この数式のどこかに
2 が入ると思ったのですが

00:04:13.870 --> 00:04:16.980
これは一体どういうことなのか
少し考えてみましょう

00:04:16.980 --> 00:04:20.620
ステップを繰り返すたびに
配列を 2 分割するとしたら

00:04:20.620 --> 00:04:23.480
要素の数を 2 倍にするたびに
反復の回数が

00:04:23.480 --> 00:04:25.600
1 つ増えることになります

00:04:26.240 --> 00:04:27.900
表をよく見てみると

00:04:27.900 --> 00:04:30.549
この考えはどうやら正しそうです

00:04:32.300 --> 00:04:34.369
配列の長さが 2 倍になるたびに

00:04:34.370 --> 00:04:37.199
アルゴリズムの反復回数が
1 回増えています

00:04:38.560 --> 00:04:42.728
これらを指数として表すと
2 の累乗になる数字は反復の数よりも必ず

00:04:42.728 --> 00:04:47.121
1 つ大きくなる
ことに気付きました

00:04:47.121 --> 00:04:51.686
ということは、このような
数式になりそうです

00:04:51.686 --> 00:04:56.209
全体的な反復回数は
2 の累乗指数が増えるたびに

00:04:56.209 --> 00:04:59.557
増加することになり
そしてもちろん

00:04:59.557 --> 00:05:01.833
これは必ず 1 ずれることになります

00:05:01.833 --> 00:05:06.380
2 の累乗指数を示す
数や式を得るには

00:05:06.380 --> 00:05:08.439
どうすればよいでしょうか

00:05:08.439 --> 00:05:12.693
まず、この数式から始めましょう
これが配列に含まれる要素の数で

00:05:12.693 --> 00:05:16.425
最終的にはこの指数になるように
するのが目標です

00:05:16.425 --> 00:05:20.305
ここで、私は昔よく実践していた
ちょっと変わった数学を思い出しました

00:05:20.305 --> 00:05:23.295
これは対数と呼ばれるもので
このような関数を

00:05:23.295 --> 00:05:25.895
別の方法で
表現することができます

00:05:25.895 --> 00:05:30.272
対数を使ってこの式を
log2 8 = 3 と表現しても

00:05:30.273 --> 00:05:32.550
まったく同じことになります

00:05:33.600 --> 00:05:35.820
この方が少しわかりやすいですね

00:05:35.820 --> 00:05:39.330
ただし、この論理を理解する上で
対数に関する深い知識が必要という

00:05:39.330 --> 00:05:41.740
わけではありません

00:05:41.740 --> 00:05:44.929
先ほど説明した方程式さえ理解していれば
まったく問題ありません

00:05:46.100 --> 00:05:48.780
そこで、さらに近似を使って
この式をよりわかりやすく

00:05:48.780 --> 00:05:50.270
してみましょう

00:05:50.270 --> 00:05:52.830
前述のとおり、定数や
1 を足しても

00:05:52.830 --> 00:05:57.280
効率はそれほど
変わりません

00:05:57.280 --> 00:06:00.869
また、これが 2 を底とした対数で
あると述べる必要もありません

00:06:00.870 --> 00:06:04.800
コンピューターサイエンスの観点からは
この対数の基底が 2 であると仮定しても

00:06:04.800 --> 00:06:06.200
おそらく問題ないでしょう

00:06:06.200 --> 00:06:10.359
これは配列を半分に分けたり
バイナリーを用いるようなものです

00:06:10.360 --> 00:06:15.350
よって 10 を底とする典型的な対数ではなく
2 を底とする対数になります

00:06:15.350 --> 00:06:17.859
そしてこれが導き出された
効率です

00:06:18.890 --> 00:06:21.500
他のツールについては
後ほどご紹介します

00:06:21.500 --> 00:06:22.700
この効率がなぜ正しいか

00:06:22.700 --> 00:06:25.740
説明するには視覚化すると
わかりやすいと思います

00:06:26.840 --> 00:06:29.380
ここで念を押しておきたいことが
1 つあります

00:06:30.510 --> 00:06:32.260
効率について学び始めた頃

00:06:32.260 --> 00:06:35.700
私は、すぐに結論に飛びついてしまう
ケースをよく目にしました

00:06:36.720 --> 00:06:39.800
元の問題だけを見て
n を底とする対数であると簡単に

00:06:39.800 --> 00:06:40.330
結論付けてしまう人が多いのです

00:06:41.450 --> 00:06:43.740
しかし、長年の開発経験から
私はこの結論が

00:06:43.740 --> 00:06:45.630
当てはまらないことを
学びました

00:06:46.690 --> 00:06:51.650
効率について質問されたときの
対処方法は主に 3 つあります

00:06:51.650 --> 00:06:54.715
その 1 つはすでに説明した
バイナリーサーチを理解した上で

00:06:54.715 --> 00:06:58.734
効率を暗記しておき
その場で速やかに

00:06:58.735 --> 00:07:00.935
回答を述べることです

00:07:00.935 --> 00:07:04.855
面接に備える場合は、基本的なアルゴリズムの
効率を暗記しておくことを

00:07:04.855 --> 00:07:06.585
強くお勧めします

00:07:06.585 --> 00:07:09.854
すぐに効率を答えられたら
とても優秀な人材だという

00:07:09.855 --> 00:07:11.335
印象を与えることができます

00:07:11.335 --> 00:07:13.854
ただし、新たな問題を出されて
そのアルゴリズムの効率を

00:07:13.855 --> 00:07:16.790
暗記していなかった場合
自力でその回答を

00:07:16.790 --> 00:07:18.450
導き出さなければ
なりません

00:07:19.450 --> 00:07:22.140
その 1 つは、証明を用いた方法です

00:07:22.140 --> 00:07:25.849
私は個人的に証明が好きではなく
実際に面接で使ったことはありませんし

00:07:25.850 --> 00:07:28.560
使っている人を見たことも
ありません

00:07:28.560 --> 00:07:32.100
証明について詳しく学びたい場合は
オンラインで入手した情報や

00:07:32.100 --> 00:07:35.610
論文を読んでみたり
詳しい人に実演してもらうとよいでしょう

00:07:35.610 --> 00:07:38.569
ここでは、証明の実用的な
アプローチについてのみご紹介します

00:07:39.910 --> 00:07:41.940
まだそのアルゴリズムを見たことがなく
ゼロから証明を行う時間がない場合は

00:07:41.940 --> 00:07:46.400
このような結果テーブルを作成すると
大いに役立つことがあるため

00:07:46.400 --> 00:07:48.810
この方法を覚えておくと
便利かもしれません

00:07:50.160 --> 00:07:53.930
結果テーブルを作成することで
パターンが浮き彫りになり

00:07:53.930 --> 00:07:57.380
配列の長さに対する
アルゴリズムの反復回数として

00:07:57.380 --> 00:08:00.730
効率を検討できるように
なるはずです

00:08:00.730 --> 00:08:02.830
効率について経験が
浅かった頃

00:08:02.830 --> 00:08:06.320
私はこのような表を使って
パターンを見出していました

00:08:06.320 --> 00:08:08.507
そしてこの手法に慣れていくうちに

00:08:08.507 --> 00:08:11.685
表がなくても自力で
パターンを特定できるようになったのです

00:08:11.685 --> 00:08:13.406
現在、面接では

00:08:13.406 --> 00:08:19.350
2 の累乗における変化など
一般的なパターンについて認識しているので

00:08:19.350 --> 00:08:21.117
以前よりもかなり短時間で問題を解けますし

00:08:21.117 --> 00:08:26.200
手も足も出ないような
問題はほとんどありません

00:08:26.200 --> 00:08:29.289
面接の場で起こりうる最悪の事態は
過去にそのアルゴリズムを

00:08:29.290 --> 00:08:32.890
見たことがなかったり
その証明を記述できないことです

00:08:33.100 --> 00:08:36.600
運悪く、見たことのないアルゴリズムに
遭遇したり、回答がわからない場合は

00:08:36.600 --> 00:08:40.390
結果テーブルを作成して
解決を試みてください

00:08:40.390 --> 00:08:43.210
問題を解こうという真摯な姿勢が
面接官に好印象を与えることも

00:08:43.210 --> 00:08:43.710
考えられます

