WEBVTT
Kind: captions
Language: ja-JP

00:00:00.950 --> 00:00:04.710
ツールがいくつか揃ったところで
基本的なアルゴリズムについて学びましょう

00:00:04.710 --> 00:00:08.809
数値順にソートされた配列に
ある数値が含まれるかどうか

00:00:08.810 --> 00:00:12.770
確認しなければならない
と仮定します

00:00:12.770 --> 00:00:16.189
目的の数値が大きい場合
配列を先頭からチェックすると

00:00:16.190 --> 00:00:19.820
アルゴリズムの実行時間が
O(n) になる可能性があります

00:00:19.820 --> 00:00:22.270
配列の終わりから始めても同様で

00:00:22.270 --> 00:00:23.960
もし小さい数値であれば

00:00:23.960 --> 00:00:27.460
最悪の場合、アルゴリズムの実行時間が
線形になってしまいます

00:00:27.460 --> 00:00:30.990
しかし、ソートされた配列の特徴を
生かしたテクニックを駆使することで

00:00:30.990 --> 00:00:33.110
この問題は簡単に解決できます

00:00:33.110 --> 00:00:34.800
この場合、配列の最後からではなく

00:00:34.800 --> 00:00:37.540
中央からチェックを
開始するとよいでしょう

00:00:37.540 --> 00:00:41.290
目的の数は配列の中央にある値よりも
大きいのか小さいのか

00:00:42.320 --> 00:00:43.970
この場合は大きいので

00:00:43.970 --> 00:00:47.640
配列の後半部分にあるはずと
推定できます

00:00:47.640 --> 00:00:50.880
つまり、配列の前半はまったく
考慮する必要がありません

00:00:50.880 --> 00:00:54.200
そして、後半部分も同じ要領で
推測を繰り返せばチェック範囲が半分で済むので

00:00:54.200 --> 00:00:57.800
効率的に作業を
進めることができます

00:00:57.800 --> 00:00:59.360
中央にある値をチェックし
目的の値が大きいか小さいか判断します

00:01:00.400 --> 00:01:03.768
目的の値はここでも中央にある
値よりも大きいため

00:01:03.768 --> 00:01:06.185
最後の値だけチェックすれば
よいことになります

00:01:06.185 --> 00:01:07.405
ここが最後です

00:01:07.405 --> 00:01:13.160
横並びの値 19 と 29 をチェックしましたが
25 は見当たりません

00:01:13.160 --> 00:01:16.395
これで、この配列に 25 は含まれないと
結論付けることができます

00:01:17.465 --> 00:01:18.155
いかがでしたか

00:01:18.155 --> 00:01:19.915
これがアルゴリズムです

00:01:19.915 --> 00:01:23.635
アルゴリズムは問題を解決するための
テクニックを難しく表現した

00:01:23.635 --> 00:01:25.550
だけと考えてください

00:01:25.550 --> 00:01:27.505
今ご紹介したのはバイナリーサーチと
呼ばれるものです

