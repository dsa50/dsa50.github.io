WEBVTT
Kind: captions
Language: ja-JP

00:00:00.240 --> 00:00:04.150
ここでもう 1 つ押さえておきたいのが
ヒープの実装についてです

00:00:04.150 --> 00:00:06.210
ヒープはツリー構造で表しますが

00:00:06.210 --> 00:00:09.290
配列が格納されていることが
多々あります

00:00:09.290 --> 00:00:11.200
なぜこのようなことが可能なのでしょうか

00:00:11.200 --> 00:00:15.430
各親要素が持つ子要素の数が
2 であることが判明しているため

00:00:15.430 --> 00:00:19.600
各レベルにあるノードの数も明らかとなり
簡単な計算をすることで次のノードが

00:00:19.600 --> 00:00:23.830
配列のどこにあるのかを判断でき
ツリーのトラバースが可能となります

00:00:23.830 --> 00:00:26.860
ソートされているこの配列を
ツリーに変換してみましょう

00:00:26.860 --> 00:00:31.220
ルートが最も大きい値なので
これが最初の要素となります

00:00:31.220 --> 00:00:35.160
その次に来る 2 つの要素は
ルートの子要素です

00:00:35.160 --> 00:00:38.580
これらの要素を
左から右に挿入します

00:00:38.580 --> 00:00:42.400
これは単なる慣例であって、実際は 2 つ目の
レベルであれば左右どちらでも構いません

00:00:42.400 --> 00:00:46.510
ツリーの各レベルは 1 つ前のレベルより
2 倍大きくなるので

00:00:46.510 --> 00:00:49.140
次のレベルには 4 つの要素があると
判断できます

00:00:49.140 --> 00:00:52.160
この作業は変数を使用して
各レベルのサイズを追跡し

00:00:52.160 --> 00:00:56.929
次のレベルに移動するたびに
値を 2 倍にすることでプログラム的に実行できます

00:00:56.930 --> 00:01:00.950
残された数値はすべて
最後のレベルの左側に挿入します

00:01:00.950 --> 00:01:01.940
できました

00:01:01.940 --> 00:01:03.290
ここで 1 つ注意点があります

00:01:03.290 --> 00:01:06.130
すべての配列がヒープ構造で
表現できるわけではありません

00:01:06.130 --> 00:01:09.339
この例では降順にソートされているため
ヒープ構造にすることが可能です

00:01:09.340 --> 00:01:13.490
通常、ヒープ構造で意味をなす順序で
配列されていることが必須となります

00:01:13.490 --> 00:01:16.960
データを配列に格納する利点は
スペースの節約につながることです

00:01:16.960 --> 00:01:19.960
配列を使用する場合は
ノードの値とインデックスを

00:01:19.960 --> 00:01:22.330
配列のスロットに格納します

00:01:22.330 --> 00:01:25.240
しかし、ツリーに対し何らかの
ノードオブジェクトを作成した場合

00:01:25.240 --> 00:01:29.630
親要素と子要素を示すポインタが
各オブジェクトに必要となるため

00:01:29.630 --> 00:01:33.649
各要素の値といくつものポインタを
格納しなければなりません

00:01:33.650 --> 00:01:36.670
しかし、配列ではポインタが必要ないため
スペースの節約になるわけです

