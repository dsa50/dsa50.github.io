<!-- udacity2.0 -->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Binary Search</title>
  <link rel="stylesheet" href="../assets/css/bootstrap.min.css">
  <link rel="stylesheet" href="../assets/css/plyr.css">
  <link rel="stylesheet" href="../assets/css/katex.min.css">
  <link rel="stylesheet" href="../assets/css/jquery.mCustomScrollbar.min.css">
  <link rel="stylesheet" href="../assets/css/styles.css">
  <link rel="shortcut icon" type="image/png" href="../assets/img/udacimak.png" />
</head>

<body>
  <div class="wrapper">
    <nav id="sidebar">
  <div class="sidebar-header">
    <h3>Basic Algorithms</h3>
  </div>

  <ul class="sidebar-list list-unstyled CTAs">
    <li>
      <a href="../index.html" class="article">Back to Home</a>
    </li>
  </ul>

  <ul class="sidebar-list list-unstyled components">
    <li class="">
      <a href="01. Binary Search.html">01. Binary Search</a>
    </li>
    <li class="">
      <a href="02. Efficiency of Binary Search.html">02. Efficiency of Binary Search</a>
    </li>
    <li class="">
      <a href="03. Binary Search Practice.html">03. Binary Search Practice</a>
    </li>
    <li class="">
      <a href="04. Binary Search Variation.html">04. Binary Search Variation</a>
    </li>
    <li class="">
      <a href="05. Binary search First and last indexes.html">05. Binary search: First and last indexes</a>
    </li>
    <li class="">
      <a href="06. Tries.html">06. Tries</a>
    </li>
    <li class="">
      <a href="07. Heaps.html">07. Heaps</a>
    </li>
    <li class="">
      <a href="08. Heapify.html">08. Heapify</a>
    </li>
    <li class="">
      <a href="09. Heap Implementation.html">09. Heap Implementation</a>
    </li>
    <li class="">
      <a href="10. Heaps Exercise.html">10. Heaps Exercise</a>
    </li>
    <li class="">
      <a href="11. Self-Balancing Tree.html">11. Self-Balancing Tree</a>
    </li>
    <li class="">
      <a href="12. Red-Black Tree Insertion.html">12. Red-Black Tree Insertion</a>
    </li>
    <li class="">
      <a href="13. Tree Rotations.html">13. Tree Rotations</a>
    </li>
    <li class="">
      <a href="14. Build a Red-Black Tree.html">14. Build a Red-Black Tree</a>
    </li>
    <li class="">
      <a href="15. Interlude.html">15. Interlude</a>
    </li>
  </ul>

  <ul class="sidebar-list list-unstyled CTAs">
    <li>
      <a href="../index.html" class="article">Back to Home</a>
    </li>
  </ul>
</nav>

    <div id="content">
      <header class="container-fluild header">
        <div class="container">
          <div class="row">
            <div class="col-12">
              <div class="align-items-middle">
                <button type="button" id="sidebarCollapse" class="btn btn-toggle-sidebar">
                  <div></div>
                  <div></div>
                  <div></div>
                </button>

                <h1 style="display: inline-block">01. Binary Search</h1>
              </div>
            </div>
          </div>
        </div>
      </header>

      <main class="container">
        <div class="row">
          <div class="col-12">
            <div class="ud-atom">
  <h3></h3>
  <div>
  <h1 id="binary-search">Binary search</h1>
<p>Binary search is probably one of the most common algorithms that we all use without even realizing we are using it.</p>
<p>To help build a little intuition for how it works, let's first look at a classic game where the most efficient way to win is to use binary search.</p>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div class="jumbotron">
  <h3>Code</h3>

  <p class="lead">If you need a code on the <a href="https://github.com/udacity"
    target="_blank">https://github.com/udacity</a>. </p>

  </ul>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <p>Obviously, there is some randomness involved in this game, so in some cases you may run out of tries before guessing correctly. However, if you use a binary search strategy, you'll find the number efficiently and win most of the time.</p>
<p>But before we look further into binary search, let's first look at an alternative: <em>Linear search.</em></p>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <h2 id="linear-search">Linear search</h2>
<p>Suppose that you have a dictionary of words and that you need to look up a particular word in this dictionary. However, this dictionary is a pretty terrible dictionary, because the words are all in a scrambled order (and not alphabetical as they usually are). What search strategy would you use to find the definition you're looking for?</p>
<p>Because the words are in a random order, the best we can do is simply to go one by one, from the first page to the last page, in a sequential manner. Sounds tedious, right? This is called <strong>linear search</strong>. We have no idea about the order of the words, so we simply have to flip through the pages, one by one, until we find the word we are looking for.</p>
<p>With the example of the guessing game, you could use linear search there as well—by simply starting with 1 and guessing every number until you get to 100 (or rather, until you run out of tries and lose the game!).</p>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <form>
    <fieldset>
      <legend><p>What would the time complexity be for <strong>linear search</strong>?</p>
<p>(Think about the worst case scenario, where the word you're looking for is on the last page of the dictionary.)</p></legend>
    </fieldset>

      <div>
        <input type="radio" value="a1556125405417" name="845107" id="a1556125405417">
        <label for="a1556125405417"><p><span class="mathquill ud-math">O(1)</span></p></label>
      </div>
      <div>
        <input type="radio" value="a1556125421167" name="845107" id="a1556125421167">
        <label for="a1556125421167"><p><span class="mathquill ud-math">O(n)</span></p></label>
      </div>
      <div>
        <input type="radio" value="a1556125594577" name="845107" id="a1556125594577">
        <label for="a1556125594577"><p><span class="mathquill ud-math">O(log(n))</span></p></label>
      </div>
      <div>
        <input type="radio" value="a1556125603426" name="845107" id="a1556125603426">
        <label for="a1556125603426"><p><span class="mathquill ud-math">O(n^2)</span></p></label>
      </div>
      <div>
        <input type="radio" value="a1556125604226" name="845107" id="a1556125604226">
        <label for="a1556125604226"><p><span class="mathquill ud-math">{O(2^n)}</span></p></label>
      </div>
      <div>
        <input type="radio" value="a1556125797925" name="845107" id="a1556125797925">
        <label for="a1556125797925"><p><span class="mathquill ud-math">{O(n!)}</span></p></label>
      </div>
  </form>

  <details>
    <summary><strong>SOLUTION:</strong></summary>
     <span class="mathquill">O(n)</span>
  </details>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <h2 id="back-to-binary-search">Back to binary search</h2>
<p>Now let's consider a different scenario: Similar to the above, we have a dictionary and a word that we want to find in that dictionary. But this time, the dictionary is sorted in alphabetical order (just as you would expect from any decent dictionary). We still don't know what page our word is on, so we'll need to search for it—but the fact that the dictionary is sorted changes the strategy we should use.</p>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <form>
    <fieldset>
      <legend><p>You're going to make your first guess about which page the word might be on. Then you'll open the dictionary and take a look to see if you're right.</p>
<p>Which page should you look at first? (Assuming you want to find the word as quickly as possible.)</p></legend>
    </fieldset>

      <div>
        <input type="radio" value="a1556129224992" name="845188" id="a1556129224992">
        <label for="a1556129224992"><p>A random page.</p></label>
      </div>
      <div>
        <input type="radio" value="a1556129279885" name="845188" id="a1556129279885">
        <label for="a1556129279885"><p>The first page.</p></label>
      </div>
      <div>
        <input type="radio" value="a1556129280483" name="845188" id="a1556129280483">
        <label for="a1556129280483"><p>The middle page (halfway through the dictionary).</p></label>
      </div>
      <div>
        <input type="radio" value="a1556129281060" name="845188" id="a1556129281060">
        <label for="a1556129281060"><p>The last page.</p></label>
      </div>
  </form>

  <details>
    <summary><strong>SOLUTION:</strong></summary>
    The middle page (halfway through the dictionary).
  </details>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <blockquote>
  <p><strong>Note:</strong> With a real dictionary, we might have some idea about the approximate location of a word. For example, if the word is "aardvark", we know it is going to be close to the beginning of the dictionary, while if it is "zebra", we know it will be close to the end. For the purposes of this example, we're going to ignore this kind of information.</p>
</blockquote>
<p>Of the above options, the best strategy we can take is to open the dictionary in the middle.</p>
<p>Then, we do the following:</p>
<ul>
<li>Compare the target word with the words on this page.</li>
<li>If the target word comes earlier (in terms of alphabetical order), then we discard the right half of the book. From now on, we will only search in the left half.</li>
<li>Similarly, if the word comes later than the words on this page, then we discard the left half of the book. From now on, we will only search in the right half.</li>
</ul>
<p>Whatever happens, we are guaranteed to be able to discard half of the search space in this first step alone.</p>
<p>Next, we repeat this process. We take the remaining half of the dictionary and we open it to the middle page. We then discard the left or right half, and repeat again. We continue this process, eliminating half of the search space at each step, until we find the target word. This is <em>binary search</em>.</p>
<p>Note that the word binary means "having two parts". Binary search means we are doing a search where, at each step, we divide the input into two parts. Also note that the data we are searching through has to be sorted.</p>
<p>Let's see what this would look like on a real data structure, such as an array:</p>
</div>

</div>
<div class="divider"></div><div class="ud-atom">
  <h3><p>Pesquisa binária</p></h3>
  <video controls>
  <source src="01. Pesquisa binária-0VN5iwEyq4c.mp4" type="video/mp4">

  <track default="false" kind="subtitles" srclang="zh-CN" src="01. Pesquisa binária-0VN5iwEyq4c.zh-CN.vtt" label="zh-CN">
  <track default="true" kind="subtitles" srclang="en-US" src="01. Pesquisa binária-0VN5iwEyq4c.en-US.vtt" label="en-US">
  <track default="false" kind="subtitles" srclang="ja-JP" src="01. Pesquisa binária-0VN5iwEyq4c.ja-JP.vtt" label="ja-JP">
  <track default="false" kind="subtitles" srclang="pt-BR" src="01. Pesquisa binária-0VN5iwEyq4c.pt-BR.vtt" label="pt-BR">
  <track default="true" kind="subtitles" srclang="en" src="01. Pesquisa binária-0VN5iwEyq4c.en.vtt" label="en">
</video>


</div>
<div class="divider"></div><div class="ud-atom">
  <h3></h3>
  <div>
  <p>In summary:</p>
<ul>
<li>Binary search is a search algorithm where we find the position of a target value by comparing the middle value with this target value.</li>
<li>If the middle value is equal to the target value, then we have our solution (we have found the position of our target value).</li>
<li>If the target value comes before the middle value, we look for the target value in the left half.</li>
<li>Otherwise, we look for the target value in the right half.</li>
<li>We repeat this process as many times as needed, until we find the target value.</li>
</ul>
</div>

</div>
<div class="divider"></div>
          </div>

          <div class="col-12">
            <p class="text-right">
              <a href="02. Efficiency of Binary Search.html" class="btn btn-outline-primary mt-4" role="button">Next Concept</a>
            </p>
          </div>
        </div>
      </main>

      <footer class="footer">
        <div class="container">
          <div class="row">
            <div class="col-12">
              <p class="text-center">
                <a href="https://us-udacity.github.io/" target="_blank">【udacity2.0 】If you need more courses, please add wechat：udacity6</a>
              </p>
            </div>
          </div>
        </div>
      </footer>
    </div>
  </div>


  <script src="../assets/js/jquery-3.3.1.min.js"></script>
  <script src="../assets/js/plyr.polyfilled.min.js"></script>
  <script src="../assets/js/bootstrap.min.js"></script>
  <script src="../assets/js/jquery.mCustomScrollbar.concat.min.js"></script>
  <script src="../assets/js/katex.min.js"></script>
  <script>
    // Initialize Plyr video players
    const players = Array.from(document.querySelectorAll('video')).map(p => new Plyr(p));

    // render math equations
    let elMath = document.getElementsByClassName('mathquill');
    for (let i = 0, len = elMath.length; i < len; i += 1) {
      const el = elMath[i];

      katex.render(el.textContent, el, {
        throwOnError: false
      });
    }

    // this hack will make sure Bootstrap tabs work when using Handlebars
    if ($('#question-tabs').length && $('#user-answer-tabs').length) {
      $("#question-tabs a.nav-link").on('click', function () {
        $("#question-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
      $("#user-answer-tabs a.nav-link").on('click', function () {
        $("#user-answer-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
    } else {
      $("a.nav-link").on('click', function () {
        $(".tab-pane").hide();
        $($(this).attr("href")).show();
      });
    }

    // side bar events
    $(document).ready(function () {
      $("#sidebar").mCustomScrollbar({
        theme: "minimal"
      });

      $('#sidebarCollapse').on('click', function () {
        $('#sidebar, #content').toggleClass('active');
        $('.collapse.in').toggleClass('in');
        $('a[aria-expanded=true]').attr('aria-expanded', 'false');
      });

      // scroll to first video on page loading
      if ($('video').length) {
        $('html,body').animate({ scrollTop: $('div.plyr').prev().offset().top});
      }

      // auto play first video: this may not work with chrome/safari due to autoplay policy
      if (players && players.length > 0) {
        players[0].play();
      }

      // scroll sidebar to current concept
      const currentInSideBar = $( "ul.sidebar-list.components li a:contains('01. Binary Search')" )
      currentInSideBar.css( "text-decoration", "underline" );
      $("#sidebar").mCustomScrollbar('scrollTo', currentInSideBar);
    });
  </script>
</body>

</html>
