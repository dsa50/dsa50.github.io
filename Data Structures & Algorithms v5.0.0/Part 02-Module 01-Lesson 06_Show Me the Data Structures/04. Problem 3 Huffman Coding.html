<!-- udacimak v1.4.4 -->
<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <meta content="ie=edge" http-equiv="X-UA-Compatible"/>
  <title>
   Problem 3: Huffman Coding
  </title>
  <link href="../assets/css/bootstrap.min.css" rel="stylesheet"/>
  <link href="../assets/css/plyr.css" rel="stylesheet"/>
  <link href="../assets/css/katex.min.css" rel="stylesheet"/>
  <link href="../assets/css/jquery.mCustomScrollbar.min.css" rel="stylesheet"/>
  <link href="../assets/css/styles.css" rel="stylesheet"/>
  <link href="../assets/img/udacimak.png" rel="shortcut icon" type="image/png">
  </link>
 </head>
 <body>
  <div class="wrapper">
   <nav id="sidebar">
    <div class="sidebar-header">
     <h3>
      Show Me the Data Structures
     </h3>
    </div>
    <ul class="sidebar-list list-unstyled CTAs">
     <li>
      <a class="article" href="../index.html">
       Back to Home
      </a>
     </li>
    </ul>
    <ul class="sidebar-list list-unstyled components">
     <li class="">
      <a href="01. Introduction to the Project.html">
       01. Introduction to the Project
      </a>
     </li>
     <li class="">
      <a href="02. Problem 1 LRU Cache.html">
       02. Problem 1: LRU Cache
      </a>
     </li>
     <li class="">
      <a href="03. Problem 2 File Recursion.html">
       03. Problem 2: File Recursion
      </a>
     </li>
     <li class="">
      <a href="04. Problem 3 Huffman Coding.html">
       04. Problem 3: Huffman Coding
      </a>
     </li>
     <li class="">
      <a href="05. Problem 4 Active Directory.html">
       05. Problem 4: Active Directory
      </a>
     </li>
     <li class="">
      <a href="06. Problem 5 Blockchain.html">
       06. Problem 5: Blockchain
      </a>
     </li>
     <li class="">
      <a href="07. Problem 6 Union and Intersection.html">
       07. Problem 6: Union and Intersection
      </a>
     </li>
     <li class="">
      <a href="Project Description - Show Me the Data Structures.html">
       Project Description - Show Me the Data Structures
      </a>
     </li>
     <li class="">
      <a href="Project Rubric - Show Me the Data Structures.html">
       Project Rubric - Show Me the Data Structures
      </a>
     </li>
    </ul>
    <ul class="sidebar-list list-unstyled CTAs">
     <li>
      <a class="article" href="../index.html">
       Back to Home
      </a>
     </li>
    </ul>
   </nav>
   <div id="content">
    <header class="container-fluild header">
     <div class="container">
      <div class="row">
       <div class="col-12">
        <div class="align-items-middle">
         <button class="btn btn-toggle-sidebar" id="sidebarCollapse" type="button">
          <div>
          </div>
          <div>
          </div>
          <div>
          </div>
         </button>
         <h1 style="display: inline-block">
          04. Problem 3: Huffman Coding
         </h1>
        </div>
       </div>
      </div>
     </div>
    </header>
    <main class="container">
     <div class="row">
      <div class="col-12">
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h1 id="overview---data-compression">
          Overview - Data Compression
         </h1>
         <p>
          In general, a data compression algorithm reduces the amount of memory (bits) required to represent a message (data). The compressed data, in turn, helps to reduce the transmission time from a sender to receiver. The sender encodes the data, and the receiver decodes the encoded data. As part of this problem, you have to implement the logic for both encoding and decoding.
         </p>
         <p>
          A data compression algorithm could be either
          <strong>
           <em>
            lossy
           </em>
          </strong>
          or
          <strong>
           <em>
            lossless
           </em>
          </strong>
          , meaning that when compressing the data, there is a loss  (lossy) or no loss (lossless) of information. The
          <strong>
           Huffman Coding
          </strong>
          is a
          <em>
           lossless
          </em>
          data compression algorithm. Let us understand the two phases - encoding and decoding with the help of an example.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h2 id="a-huffman-encoding">
          A. Huffman Encoding
         </h2>
         <p>
          Assume that we have a string message
          <code>
           AAAAAAABBBCCCCCCCDDEEEEEE
          </code>
          comprising of 25 characters to be encoded. The string message can be an unsorted one as well. We will have two phases in encoding - building the Huffman tree (a binary tree), and generating the encoded data. The following steps illustrate the Huffman encoding:
         </p>
         <h3 id="-font-colorbluephase-i---build-the-huffman-tree-font-br">
          **
          <font color="blue">
           Phase I - Build the Huffman Tree
          </font>
          **
          <br/>
         </h3>
         <p>
          A Huffman tree is built in a bottom-up approach.
         </p>
         <ol>
          <li>
           First, determine the frequency of each character in the message. In our example, the following table presents the frequency of each character.
          </li>
         </ol>
         <table>
          <thead>
           <tr>
            <th id="(unique)_character" style="text-align:center;">
             (Unique) Character
            </th>
            <th id="frequency" style="text-align:center;">
             Frequency
            </th>
           </tr>
          </thead>
          <tbody>
           <tr>
            <td style="text-align:center;">
             A
            </td>
            <td style="text-align:center;">
             7
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             B
            </td>
            <td style="text-align:center;">
             3
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             C
            </td>
            <td style="text-align:center;">
             7
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             D
            </td>
            <td style="text-align:center;">
             2
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             E
            </td>
            <td style="text-align:center;">
             6
            </td>
           </tr>
          </tbody>
         </table>
         <ol start="2">
          <li>
           <p>
            Each row in the table above can be represented as a
            <em>
             node
            </em>
            having a character, frequency, left child, and right child. In the next step, we will repeatedly require to pop-out the node having the lowest frequency. Therefore, build and sort a
            <em>
             list
            </em>
            of nodes in the order lowest to highest frequencies. Remember that a
            <em>
             list
            </em>
            preserves the order of elements in which they are appended.
           </p>
           <p>
            We would need our
            <em>
             list
            </em>
            to work as a
            <strong>
             <a href="https://en.wikipedia.org/wiki/Priority_queue" rel="noopener noreferrer" target="_blank">
              priority queue
             </a>
            </strong>
            , where a node that has lower frequency should have a higher priority to be popped-out.  The following snapshot will help you visualize the example considered above:
           </p>
          </li>
         </ol>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/screenshot-2020-04-27-at-5.15.56-pm.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <blockquote>
          <p>
           Can you come up with other data structures to create a priority queue? How about using a
           <em>
            min-heap
           </em>
           instead of a list? You are free to choose from anyone.
          </p>
         </blockquote>
         <ol start="3">
          <li>
           <p>
            Pop-out two nodes with the minimum frequency from the
            <em>
             priority queue
            </em>
            created in the above step.
           </p>
          </li>
          <li>
           <p>
            Create a new node with a frequency equal to the sum of the two nodes picked in the above step. This new node would become an
            <em>
             internal node
            </em>
            in the Huffman tree, and the two nodes would become the children.  The lower frequency node becomes a left child, and the higher frequency node becomes the right child. Reinsert the newly created node back into the priority queue.
            <br/>
           </p>
           <p>
            <strong>
             Do you think that this reinsertion requires the sorting of priority queue again?
            </strong>
            If yes, then a
            <em>
             min-heap
            </em>
            could be a better choice due to the lower complexity of sorting the elements, every time there is an insertion.
           </p>
          </li>
          <li>
           <p>
            Repeat steps #3 and #4 until there is a single element left in the priority queue. The snapshots below present the building of a Huffman tree.
           </p>
          </li>
         </ol>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/huffman-tree-1.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/huffman-tree-2.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <ol start="6">
          <li>
           For each node, in the Huffman tree, assign a bit
           <code>
            0
           </code>
           for left child and a
           <code>
            1
           </code>
           for right child. See the final Huffman tree for our example:
          </li>
         </ol>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <figure class="figure">
          <img alt="" class="img img-fluid" src="img/huffman-tree-3.png"/>
          <figcaption class="figure-caption">
          </figcaption>
         </figure>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <h3 id="font-colorbluephase-ii---generate-the-encoded-datafontbr">
          <strong>
           <font color="blue">
            Phase II - Generate the Encoded Data
           </font>
          </strong>
          <br/>
         </h3>
         <ol start="7">
          <li>
           Based on the Huffman tree, generate unique binary code for each character of our string message. For this purpose, you'd have to traverse the path from root to the leaf node.
          </li>
         </ol>
         <table>
          <thead>
           <tr>
            <th id="(unique)_character" style="text-align:center;">
             (Unique) Character
            </th>
            <th id="frequency" style="text-align:center;">
             Frequency
            </th>
            <th id="huffman_code">
             Huffman Code
            </th>
           </tr>
          </thead>
          <tbody>
           <tr>
            <td style="text-align:center;">
             D
            </td>
            <td style="text-align:center;">
             2
            </td>
            <td>
             000
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             B
            </td>
            <td style="text-align:center;">
             3
            </td>
            <td>
             001
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             E
            </td>
            <td style="text-align:center;">
             6
            </td>
            <td>
             01
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             A
            </td>
            <td style="text-align:center;">
             7
            </td>
            <td>
             10
            </td>
           </tr>
           <tr>
            <td style="text-align:center;">
             C
            </td>
            <td style="text-align:center;">
             7
            </td>
            <td>
             11
            </td>
           </tr>
          </tbody>
         </table>
         <blockquote>
          <p>
           <strong>
            Points to Notice
           </strong>
           <br/>
          </p>
          <ul>
           <li>
            Notice that the whole code for any character is
            <strong>
             <em>
              not
             </em>
            </strong>
            a prefix of any other code. Hence, the Huffman code is called a
            <strong>
             <em>
              <a href="https://en.wikipedia.org/wiki/Prefix_code" rel="noopener noreferrer" target="_blank">
               Prefix code
              </a>
             </em>
            </strong>
            .
           </li>
           <li>
            Notice that the binary code is shorter for the more frequent character, and vice-versa.
           </li>
           <li>
            The Huffman code is generated in such a way that the entire string message would now require a much lesser amount of memory in binary form.
           </li>
           <li>
            Notice that each node present in the original
            <em>
             priority queue
            </em>
            has become a
            <em>
             leaf node
            </em>
            in the final Huffman tree.
           </li>
          </ul>
         </blockquote>
         <p>
          This way, our encoded data would be
          <code>
           1010101010101000100100111111111111111000000010101010101
          </code>
         </p>
         <h2 id="b-huffman-decoding">
          B. Huffman Decoding
         </h2>
         <p>
          Once we have the encoded data, and the (pointer to the root of) Huffman tree, we can easily decode the encoded data using the following steps:
         </p>
         <ol>
          <li>
           Declare a blank decoded string
          </li>
          <li>
           Pick a bit from the encoded data, traversing from left to right.
          </li>
          <li>
           Start traversing the Huffman tree from the root.
          </li>
         </ol>
         <ul>
          <li>
           If the current bit of encoded data is
           <code>
            0
           </code>
           , move to the left child, else move to the right child of the tree if the current bit is
           <code>
            1
           </code>
           .
          </li>
          <li>
           If a leaf node is encountered, append the (alphabetical) character of the leaf node to the decoded string.
          </li>
         </ul>
         <ol>
          <li>
           Repeat steps #2 and #3 until the encoded data is completely traversed.
          </li>
         </ol>
         <p>
          You will have to implement the logic for both encoding and decoding in the following template. Also, you will need to create the sizing schemas to present a summary.
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <pre><code>import sys

def huffman_encoding(data):
    pass

def huffman_decoding(data,tree):
    pass

if __name__ == "__main__":
    codes = {}

    a_great_sentence = "The bird is the word"

    print ("The size of the data is: {}\n".format(sys.getsizeof(a_great_sentence)))
    print ("The content of the data is: {}\n".format(a_great_sentence))

    encoded_data, tree = huffman_encoding(a_great_sentence)

    print ("The size of the encoded data is: {}\n".format(sys.getsizeof(int(encoded_data, base=2))))
    print ("The content of the encoded data is: {}\n".format(encoded_data))

    decoded_data = huffman_decoding(encoded_data, tree)

    print ("The size of the decoded data is: {}\n".format(sys.getsizeof(decoded_data)))
    print ("The content of the encoded data is: {}\n".format(decoded_data))</code></pre>
        </div>
       </div>
       <div class="divider">
       </div>
       <div class="ud-atom">
        <h3>
        </h3>
        <div>
         <hr/>
         <h3 id="visualization-resource">
          Visualization Resource
         </h3>
         <p>
          Check this website to visualize the Huffman encoding for any string message -
          <a href="https://people.ok.ubc.ca/ylucet/DS/Huffman.html" rel="noopener noreferrer" target="_blank">
           Huffman Visualization!
          </a>
         </p>
        </div>
       </div>
       <div class="divider">
       </div>
      </div>
      <div class="col-12">
       <p class="text-right">
        <a class="btn btn-outline-primary mt-4" href="05. Problem 4 Active Directory.html" role="button">
         Next Concept
        </a>
       </p>
      </div>
     </div>
    </main>
    <footer class="footer">
     <div class="container">
      <div class="row">
       <div class="col-12">
        <p class="text-center">
         udacity2.0 If you need the newest courses Plase add me wechat: udacity6
        </p>
       </div>
      </div>
     </div>
    </footer>
   </div>
  </div>
  <script src="../assets/js/jquery-3.3.1.min.js">
  </script>
  <script src="../assets/js/plyr.polyfilled.min.js">
  </script>
  <script src="../assets/js/bootstrap.min.js">
  </script>
  <script src="../assets/js/jquery.mCustomScrollbar.concat.min.js">
  </script>
  <script src="../assets/js/katex.min.js">
  </script>
  <script>
   // Initialize Plyr video players
    const players = Array.from(document.querySelectorAll('video')).map(p => new Plyr(p));

    // render math equations
    let elMath = document.getElementsByClassName('mathquill');
    for (let i = 0, len = elMath.length; i < len; i += 1) {
      const el = elMath[i];

      katex.render(el.textContent, el, {
        throwOnError: false
      });
    }

    // this hack will make sure Bootstrap tabs work when using Handlebars
    if ($('#question-tabs').length && $('#user-answer-tabs').length) {
      $("#question-tabs a.nav-link").on('click', function () {
        $("#question-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
      $("#user-answer-tabs a.nav-link").on('click', function () {
        $("#user-answer-tab-contents .tab-pane").hide();
        $($(this).attr("href")).show();
      });
    } else {
      $("a.nav-link").on('click', function () {
        $(".tab-pane").hide();
        $($(this).attr("href")).show();
      });
    }

    // side bar events
    $(document).ready(function () {
      $("#sidebar").mCustomScrollbar({
        theme: "minimal"
      });

      $('#sidebarCollapse').on('click', function () {
        $('#sidebar, #content').toggleClass('active');
        $('.collapse.in').toggleClass('in');
        $('a[aria-expanded=true]').attr('aria-expanded', 'false');
      });

      // scroll to first video on page loading
      if ($('video').length) {
        $('html,body').animate({ scrollTop: $('div.plyr').prev().offset().top});
      }

      // auto play first video: this may not work with chrome/safari due to autoplay policy
      if (players && players.length > 0) {
        players[0].play();
      }

      // scroll sidebar to current concept
      const currentInSideBar = $( "ul.sidebar-list.components li a:contains('04. Problem 3: Huffman Coding')" )
      currentInSideBar.css( "text-decoration", "underline" );
      $("#sidebar").mCustomScrollbar('scrollTo', currentInSideBar);
    });
  </script>
 </body>
</html>
