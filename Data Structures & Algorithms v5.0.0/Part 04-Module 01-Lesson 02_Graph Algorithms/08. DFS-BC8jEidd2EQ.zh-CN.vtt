WEBVTT
Kind: captions
Language: zh-CN

00:00:00.270 --> 00:00:03.656
图的深度优先搜索 简称 DFS

00:00:03.656 --> 00:00:08.176
和树中的 DFS 操作原理是一样的

00:00:08.176 --> 00:00:10.509
请注意 图查找和图遍历

00:00:10.509 --> 00:00:13.655
差不多是一回事

00:00:13.655 --> 00:00:17.340
遍历时 你会查看每个元素

00:00:17.340 --> 00:00:21.695
而在查找时 只是当你找到要找的元素后 就会停止遍历

00:00:21.696 --> 00:00:24.355
和树不一样的是 图中没有根

00:00:24.355 --> 00:00:27.410
因此没有明显的起始位置

00:00:27.410 --> 00:00:29.460
你可以从任何节点开始

00:00:29.460 --> 00:00:32.970
首先将所选节点标为已查看

00:00:32.970 --> 00:00:36.600
DFS 通常会用到堆栈

00:00:36.600 --> 00:00:38.800
以便将刚查看的节点存储到堆栈中

00:00:39.990 --> 00:00:43.255
接着选一条边 然后找到相连的节点 将节点标为已查看

00:00:43.255 --> 00:00:47.347
并将其添加到堆栈中

00:00:47.347 --> 00:00:50.620
只要还有更多边和未查看的节点

00:00:50.620 --> 00:00:52.669
就不断重复这些步骤

00:00:53.720 --> 00:00:56.629
当你遇到之前查看过的节点

00:00:56.630 --> 00:00:59.450
则返回到上一个节点并尝试另一条边

00:01:00.710 --> 00:01:05.300
如果所有边都不存在新的节点 则从堆栈中弹出当前的节点

00:01:05.300 --> 00:01:10.600
然后返回到上一个节点 也就是堆栈中的下一个节点

00:01:10.600 --> 00:01:14.800
一直执行这一方法 直到从堆栈中取出了所有元素

00:01:14.800 --> 00:01:16.200
或找到要找的节点

00:01:17.280 --> 00:01:21.760
DFS 的另一个常见实施方法是使用递归 而不是堆栈

00:01:22.820 --> 00:01:27.500
可以想象出 你只是不断重复相同的流程

00:01:27.500 --> 00:01:30.429
选择一条边并将节点标为已查看 直到不存在新的节点可以查看

00:01:31.540 --> 00:01:36.900
这就是基线条件 然后返回到上一级递归

00:01:36.900 --> 00:01:38.670
也就是查找中的上一个节点

00:01:39.760 --> 00:01:44.210
对于该算法 我们明确访问了每条边和每个顶点一次

00:01:45.440 --> 00:01:48.560
,因此 运行时间通常是这样的

00:01:48.560 --> 00:01:52.600
边的条数加上顶点个数

00:01:53.800 --> 00:01:58.520
你可能注意到了 我们实际上访问了每条边两次

00:01:58.520 --> 00:01:59.869
一次是去查看 一次是返回

00:02:00.930 --> 00:02:03.930
运行时间理应是 2E

00:02:03.930 --> 00:02:06.850
但是近似值是一样的

00:02:06.850 --> 00:02:11.368
边的数量本身已经很好地总结了运行时间

00:02:11.368 --> 00:02:16.130
但是添加 V 的数量 是考虑到查看顶点的时间

00:02:16.130 --> 00:02:19.832
精确时间有所不同 取决于你所选的数据结构

00:02:19.832 --> 00:02:22.853
所以在被问到时 要注意根据你的实现来回答

