WEBVTT
Kind: captions
Language: ja-JP

00:00:00.430 --> 00:00:04.710
再帰はコンピューターサイエンスの中でも
特に難しくわかりにくい領域です

00:00:04.710 --> 00:00:08.230
ある地点で行き止まったら
徹底的に例を検証して

00:00:08.230 --> 00:00:10.930
解決の糸口が見つかるまで
他の例を探し続けなければなりません

00:00:12.540 --> 00:00:15.629
つまり自らを呼び出す関数を
作成するのです

00:00:17.180 --> 00:00:20.900
ごく基本的な擬似コードの例を
見てみましょう

00:00:21.740 --> 00:00:24.380
このコードは特に高度な
ことは行いませんが

00:00:24.380 --> 00:00:26.790
再帰関数の主な要素が
記されています

00:00:28.320 --> 00:00:31.700
まず、再帰関数はある時点で
自分自身を呼び出さなければなりません

00:00:33.140 --> 00:00:36.600
また、再帰関数には
ベースケースが必要です

00:00:36.600 --> 00:00:40.100
再帰関数はある意味
while ループのようなものと

00:00:40.100 --> 00:00:40.880
考えることができます

00:00:42.800 --> 00:00:44.530
つまり、終了条件に到達するまで
同じコードを何度も

00:00:44.530 --> 00:00:46.630
繰り返すことになります

00:00:48.460 --> 00:00:51.960
再帰関数ではベースケースが
この終了条件のような役割を果たします

00:00:51.960 --> 00:00:53.410
つまり、いつ終了すべきか指定するのです

00:00:54.800 --> 00:00:56.879
このようにベースケースがなければ

00:00:56.880 --> 00:01:00.430
無限再帰と呼ばれる状態から
抜け出せなくなる可能性があります

00:01:00.430 --> 00:01:04.700
無限再帰とはコードが自分自身を
呼び出し続けて、何度も実行を

00:01:04.700 --> 00:01:07.180
繰り返すことを意味します

00:01:07.180 --> 00:01:11.160
呼び出しの終了を指示していないと
この動作は永遠に続きます

00:01:12.720 --> 00:01:15.250
再帰関数が行わなければならない
3 つ目の作業はどこかの時点で

00:01:15.250 --> 00:01:17.619
入力パラメーターを
変更することです

00:01:18.740 --> 00:01:20.839
入力パラメーターを変更しなかったり

00:01:20.840 --> 00:01:22.770
実行を繰り返すたびに変更する条件を

00:01:22.770 --> 00:01:26.119
指定しなければ、いつ呼び出しを
終了すべきか判断できません

00:01:27.325 --> 00:01:30.580
その結果、無限再帰という状態に
陥ってしまいます

00:01:32.585 --> 00:01:34.934
ではここで、例を見てみましょう

00:01:34.935 --> 00:01:36.805
まず、このコードから開始し
こちら側には

00:01:36.805 --> 00:01:40.133
実行する主なコマンドラインを
それぞれ記述します

00:01:40.133 --> 00:01:46.765
そして、入力値 2 で関数の呼び出しを
開始します

00:01:46.765 --> 00:01:49.615
この if 節から始めます

00:01:49.615 --> 00:01:51.765
入力値は 2 であり

00:01:51.765 --> 00:01:54.505
この値は 0 より大きいので
else ブロックに移動します

00:01:55.550 --> 00:01:59.550
可変出力に値を割り当てる前に
まずこれについて評価を行います

00:02:01.100 --> 00:02:05.260
入力が -1 なので、2-1 になります

00:02:05.260 --> 00:02:07.550
この関数を再び呼び出しますが
今回は入力値 2 ではなく

00:02:07.550 --> 00:02:10.222
1 で呼び出します'\n'

00:02:11.980 --> 00:02:13.570
いよいよ複雑になってきました

00:02:14.720 --> 00:02:17.970
コンピューターは入力値 2 で
初期呼び出しが終了していないことを

00:02:17.970 --> 00:02:19.240
認識しています

00:02:19.240 --> 00:02:22.330
呼び出しが終了していないまま
このブロックに移ると

00:02:23.390 --> 00:02:26.290
コンピューターの一時記憶に
このことが記憶されます

00:02:26.300 --> 00:02:30.300
しかし、一時記憶域は原則的に
この初期コードをすべてコピーするため

00:02:30.300 --> 00:02:33.250
もう一度初期呼び出しを行いますが
今回は入力値 1 で呼び出します

00:02:34.160 --> 00:02:37.750
この初期呼び出しが終了しておらず
初期呼び出しの中で呼び出しを

00:02:37.750 --> 00:02:40.770
行っていることを示すために
ここでインデントを使用します

00:02:42.115 --> 00:02:44.110
それでは、もう一度やってみましょう

00:02:44.110 --> 00:02:48.600
今度は入力値 1 を使用しますが
この値も 0 より大きいので

00:02:48.600 --> 00:02:50.230
else ブロックに移動します

00:02:51.930 --> 00:02:54.210
ここでも同じ現象が起きます

00:02:54.210 --> 00:02:57.810
出力への割り当てを行う前に
この再帰ステートメントを実行する必要があります

00:02:59.510 --> 00:03:03.945
今回の入力値は 1 で
1-1 は 0 となります

00:03:03.945 --> 00:03:07.839
そして、もう一度この再帰を
呼び出しますが、値は 1 や 2 ではなく

00:03:07.839 --> 00:03:08.965
0 にします

00:03:10.695 --> 00:03:14.345
まだ呼び出しが終了しておらず
値も返していませんが

00:03:14.345 --> 00:03:18.645
次の段階に移行し、呼び出しの実行を再開する必要があるため
ここでもインデントを使用して

00:03:18.645 --> 00:03:19.835
呼び出しが終了していないことを示します

00:03:21.255 --> 00:03:22.995
では、もう一度やってみましょう

00:03:22.995 --> 00:03:25.920
ここで少し面白くなってきます

00:03:25.920 --> 00:03:30.720
入力値が 0 なので、この else ブロックでは
何も実行しません

00:03:30.720 --> 00:03:32.640
よって else ブロックには移りません

00:03:32.640 --> 00:03:37.790
0 を返すので、
ここに 0 と表示されます

00:03:38.870 --> 00:03:41.820
今回は呼び出しに対して
何らかの値を返したので

00:03:41.820 --> 00:03:46.340
入力値 0 でこの再帰のことは忘れ
先ほど扱った入力値 1 で

00:03:46.340 --> 00:03:49.100
その再帰に戻ります

00:03:50.320 --> 00:03:53.436
それでは
入力値 1 の場合に戻ります

00:03:53.436 --> 00:03:57.330
ここで説明したように
このステートメントを 0 と評価します

00:03:58.630 --> 00:04:03.280
先ほども説明したとおり
再帰ブロックを呼び出して 0 を返しました

00:04:03.280 --> 00:04:07.443
よって、このステートメント全体は
0 を評価することになり

00:04:07.443 --> 00:04:10.460
0 を出力に割り当てることができます

00:04:10.460 --> 00:04:14.582
入力値が 1 の呼び出しの
戻り値はこのように

00:04:14.582 --> 00:04:17.740
0 という値になります

00:04:17.740 --> 00:04:21.225
そこで、この再帰ブロックのことは
いったん忘れて

00:04:21.225 --> 00:04:25.690
入力値が 2 の呼び出しに
戻ることにします

00:04:25.690 --> 00:04:29.460
元の呼び出しに戻りました
これは入力値 1 で再帰だった

00:04:29.460 --> 00:04:35.219
呼び出しであり
0 と評価されたものです

00:04:35.220 --> 00:04:38.850
よって 0 は出力と等しいと言えます

00:04:40.230 --> 00:04:44.770
これで 0 を返すことができ
初期呼び出しも終了しました

00:04:46.180 --> 00:04:48.135
よって、初期呼び出しが 0 を返します

00:04:49.260 --> 00:04:52.620
再帰がとても複雑なのは
この 1 つのメソッドから開始しなければならず

00:04:52.620 --> 00:04:55.710
何回呼び出しを行わなければならないか
まったく見当がつかないためです

00:04:57.000 --> 00:05:00.300
再帰関数を使用して
問題に取り組む際に

00:05:00.300 --> 00:05:04.109
私はよく表を作成したり
このように手順をリスト化して

00:05:04.110 --> 00:05:07.970
再帰ブロックに到達するたびに
値の追跡を行っています

00:05:09.620 --> 00:05:13.880
コンピューターによる三角関数の処理を
イメージするとわかりやすいかもしれません

00:05:13.880 --> 00:05:17.710
まずこの初期関数から開始して
別の呼び出しを行い

00:05:17.710 --> 00:05:19.570
次から次へと
他の関数を繰り返し

00:05:19.570 --> 00:05:20.680
実行します

00:05:20.680 --> 00:05:23.950
すると、最終的に元の関数に
辿り着くことになります

00:05:25.900 --> 00:05:28.799
ご覧いただいたように、これらのコードは
順序どおりに行を実行します

00:05:28.800 --> 00:05:31.830
再帰ブロックに到達するまで
出力には値が割り当てられず

00:05:31.830 --> 00:05:34.729
何度でも呼び出しが
繰り返されます

00:05:36.700 --> 00:05:39.770
再帰コードの記述には
細心の注意が必要です

00:05:39.770 --> 00:05:41.560
ベースケースが正しく設定されていないと

00:05:41.560 --> 00:05:43.490
無限再帰の状態に
陥る可能性があります

00:05:44.800 --> 00:05:47.110
ではベースケースを少しだけ
変更してみましょう

00:05:48.480 --> 00:05:51.250
&gt;= から &gt; を削除し
= に置き換えて

00:05:51.250 --> 00:05:52.910
== にしてみます

00:05:54.200 --> 00:05:58.560
すると入力値が 2 であれ 1 であれ
あるいは 4 や 100 万であっても

00:05:58.560 --> 00:06:01.500
このコードは問題なく実行されます

00:06:01.500 --> 00:06:04.680
しかし入力値が
0 未満の場合

00:06:04.680 --> 00:06:06.190
このコードは値を返しません

00:06:07.700 --> 00:06:10.890
-2 で開始した場合は
if ブロックをスキップして

00:06:10.890 --> 00:06:13.650
1 を減算し続けます

00:06:13.650 --> 00:06:16.640
次の入力値は -3 になります

00:06:16.640 --> 00:06:18.657
この値から 1 を引くと -4 になります

00:06:18.658 --> 00:06:21.220
さらに 1 引くと -5 というように続きます

00:06:22.320 --> 00:06:27.840
&amp;lt; を使用した場合
開始値が -2 または

00:06:27.840 --> 00:06:32.454
-50、あるいは -100 万であれば
ベースケースに到達した時点ですぐに終了します

00:06:32.454 --> 00:06:35.657
ここで重要なのは、再帰ステートメントに
含まれる可能性のあるすべての

00:06:35.657 --> 00:06:36.750
入力値を考慮することです

00:06:38.000 --> 00:06:42.160
最後に、再帰ブロックで何が

00:06:42.160 --> 00:06:45.480
起こっているのか全然わからない場合は
必要に応じて print ステートメントを使います

00:06:45.480 --> 00:06:47.290
中間値を出力すれば

00:06:47.290 --> 00:06:51.300
各ステップで行われているコードの動作を
ある程度把握できるようになります

