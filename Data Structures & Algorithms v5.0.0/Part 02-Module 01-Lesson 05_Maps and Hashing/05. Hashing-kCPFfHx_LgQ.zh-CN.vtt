WEBVTT
Kind: captions
Language: zh-CN

00:00:00.350 --> 00:00:03.740
那么 这个神奇的哈希函数原理到底是什么？

00:00:03.740 --> 00:00:07.780
哈希函数的目的是将某些值存储在

00:00:07.780 --> 00:00:10.370
可以轻松存储和检索的位置

00:00:10.370 --> 00:00:14.759
你给它一个值 它会根据某个公式转换该值

00:00:14.760 --> 00:00:19.460
然后返回该值的编码版本 经常是数组中的索引

00:00:19.460 --> 00:00:23.200
我们通过示例来讲解这一流程

00:00:23.200 --> 00:00:25.780
假设你要举办一场大型活动

00:00:25.780 --> 00:00:29.200
比如某种类型的音乐爱好者活动

00:00:29.200 --> 00:00:32.820
任何想参加活动的人都必须提前买票

00:00:32.820 --> 00:00:36.740
所有这些门票都是随机编号的 这些编号印在了

00:00:36.740 --> 00:00:40.736
纸质门票的条形码中 大家可以在第一次入场时递给你

00:00:40.736 --> 00:00:45.560
当人们在入场处递门票时 你必须能够

00:00:45.560 --> 00:00:45.800
快速查找门票编号

00:00:46.950 --> 00:00:50.910
将门票编号存储在这种强大的哈希函数中

00:00:50.910 --> 00:00:52.379
太适合这种场合了

00:00:52.380 --> 00:00:55.320
你已经拥有所有数字 只需要找到一种哈希函数

00:00:55.320 --> 00:00:59.480
可以将它们转换成哈希值 以便轻松地存储它们

00:01:01.200 --> 00:01:05.209
哈希函数的常见使用规律是将一个庞大数字的最后几位数

00:01:05.209 --> 00:01:09.300
除以一个保持不变的数字

00:01:09.300 --> 00:01:13.920
并根据余数来将该庞大数字存到数组中的某个位置

00:01:15.330 --> 00:01:19.179
在这种情况下 余数直接变成数组的索引

00:01:20.300 --> 00:01:22.259
为何这种策略可行呢？

00:01:22.260 --> 00:01:26.720
如果我们为每个门票分配的编号在 0 到 100 之间

00:01:26.720 --> 00:01:31.880
那么我们可以轻松地将这些编号都存储在数组中 并通过索引立即找到它们

00:01:31.880 --> 00:01:35.200
如果数字很大 并且是随机的 就像之前的示例一样

00:01:35.200 --> 00:01:39.340
我们则需要某种方式来快速地将这些数字转换成索引

00:01:40.670 --> 00:01:43.220
这就是常量时间查找的工作原理

00:01:43.220 --> 00:01:45.590
你为你的数据分配一个哈希函数

00:01:45.590 --> 00:01:49.300
然后返回哈希代码 并变成数组索引

00:01:50.150 --> 00:01:54.220
你可以转到数组中 以常量时间查找原始值

00:01:54.220 --> 00:01:57.390
因为用索引查找数组是常量时间

00:01:58.410 --> 00:02:02.679
那为何使用庞大数字的最后几位数呢？

00:02:02.680 --> 00:02:06.650
在多数情况下 最后几位数几乎都是随机的

00:02:06.650 --> 00:02:09.590
如果你按照数字顺序分配这些数据

00:02:09.590 --> 00:02:12.820
前面几位数肯定不是随机的

00:02:12.820 --> 00:02:16.269
很有可能是以 1、2、3 等开头

00:02:16.270 --> 00:02:20.170
而不是 7、8、9 等后几位数开头

