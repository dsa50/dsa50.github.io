WEBVTT
Kind: captions
Language: ja-JP

00:00:00.800 --> 00:00:04.700
この方程式系は文字列キーを
使えるのが非常に便利で

00:00:04.700 --> 00:00:08.800
文字を数字に変換する
ハッシュ関数を使って

00:00:08.800 --> 00:00:09.430
問題を解くことができます

00:00:09.430 --> 00:00:14.140
個々の文字は簡単に
ASCII 値に変換できますし

00:00:14.140 --> 00:00:17.450
多くのプログラミング言語には
そのための関数が組み込まれています

00:00:18.570 --> 00:00:22.550
ASCII 値を式と組み合わせることで
各文字に対する固有のハッシュを

00:00:22.550 --> 00:00:23.990
取得できます

00:00:23.990 --> 00:00:26.900
では、実際にハッシュ関数を
見てみましょう

00:00:26.900 --> 00:00:29.310
ハッシュ関数にはトレードオフがあります

00:00:29.310 --> 00:00:31.610
すべての単語を
それぞれのバケットに入れるのか

00:00:31.610 --> 00:00:36.280
衝突を許可してなるべくシンプルな
ハッシュ関数を使うべきか

00:00:36.280 --> 00:00:41.180
たとえば、単語数が 30 以下の場合
ASCII 値をハッシュ値として

00:00:41.180 --> 00:00:44.860
文字列の最初の文字に使用するだけで
おそらく十分でしょう

00:00:44.860 --> 00:00:47.300
Java では文字列キーの標準的な

00:00:47.300 --> 00:00:52.830
ハッシュコード関数は
衝突を許可してでも巨大なハッシュデーブルの利用を優先します

00:00:52.830 --> 00:00:55.410
式はこのようになります

00:00:55.410 --> 00:00:58.980
たとえば
UDACITY という単語をハッシュ化する場合は

00:00:58.980 --> 00:01:02.879
文字列の最初の 2 文字
UD から開始します

00:01:02.880 --> 00:01:06.130
これらの ASCII 値を
方程式に代入し

00:01:06.130 --> 00:01:08.800
この文字列に固有の
ハッシュ値を取得します

00:01:10.900 --> 00:01:11.670
なぜこれでいいのでしょうか

00:01:11.670 --> 00:01:16.950
各文字の ASCII 値を何らかの数
たとえば 31 でかけると

00:01:16.950 --> 00:01:21.150
各数表現または
ハッシュ値は

00:01:21.150 --> 00:01:24.370
確実にその文字列に
固有のものになります

00:01:24.370 --> 00:01:26.490
このようなハッシュ関数は
各文字列に対して固有の

00:01:26.490 --> 00:01:30.270
バケットが必要な
ディクショナリを使用する場合に便利ですが

00:01:30.270 --> 00:01:35.348
3～4 文字しかない文字列には
すでに膨大なハッシュ値が存在します

00:01:36.550 --> 00:01:39.200
ここではトレードオフがとても重要となります

00:01:39.200 --> 00:01:44.380
十分なスペースがある限り
一意のハッシュ値はとても便利です

00:01:44.380 --> 00:01:48.110
最後に、31 という数を使った理由は何でしょうか

00:01:48.110 --> 00:01:51.560
最も古いハッシュ関数では
31 という数の特性を生かしていました

00:01:51.560 --> 00:01:55.740
そして、このような文字列のハッシュ化に
この数が非常に適しているという

00:01:55.740 --> 00:01:57.220
研究結果があるためです

00:01:58.560 --> 00:02:02.840
しかしその後、より複雑なハッシュ関数が
いくつも発見されており

00:02:02.840 --> 00:02:08.150
あらゆる状況に最適な値とわけではなく
単なる慣習として 31 が使われています

00:02:08.150 --> 00:02:12.730
目的のキーの解決法を設計するのが
最も重要なプロセスであり

00:02:12.730 --> 00:02:15.450
これらの慣習にとらわれ過ぎない
ようにするのが重要です

