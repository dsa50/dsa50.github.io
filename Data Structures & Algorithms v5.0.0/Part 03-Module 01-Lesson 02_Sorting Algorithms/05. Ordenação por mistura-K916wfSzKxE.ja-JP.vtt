WEBVTT
Kind: captions
Language: ja-JP

00:00:00.820 --> 00:00:04.370
では頻繁に利用される別のソートアルゴリズム
マージソートについて説明しましょう

00:00:05.490 --> 00:00:10.900
概要を述べるなら
大きな配列をできるだけ細かく分割し

00:00:10.900 --> 00:00:13.670
その後は比較とソートを
繰り返しながら

00:00:13.670 --> 00:00:16.280
再構築するというアイデアです

00:00:16.280 --> 00:00:20.790
配列を分割して
すべての部分をソートして

00:00:20.790 --> 00:00:23.549
再び構築するという考え方は
一般的に分割統治法と呼ばれます

00:00:24.660 --> 00:00:28.250
いくつかの効率的なソートアルゴリズムが
この手法を中核としています

00:00:29.580 --> 00:00:32.199
では例を見ながら、マージソートが
どう機能するか見ていきましょう

00:00:33.210 --> 00:00:38.300
まず配列をそれぞれが 1 要素を持つ
多数の配列に分割し

00:00:39.230 --> 00:00:41.160
そして再度構築する
必要があります

00:00:42.790 --> 00:00:46.269
なぜ 1 要素が最後ではなく
冒頭に配置されているか

00:00:46.270 --> 00:00:47.460
不思議に思うかもしれません

00:00:47.460 --> 00:00:49.580
こうした細かい点は
気にする必要はありません

00:00:49.580 --> 00:00:52.518
これは実装によって
異なります

00:00:52.518 --> 00:00:57.330
このステップではサイズ 2 の配列と
サイズ 1 の配列のみがあります

00:00:58.700 --> 00:01:02.610
まずこの 2 つの要素を比較し
どちらが小さいかを判断します

00:01:02.610 --> 00:01:05.929
1 が小さいので
新しい配列の先頭で

00:01:05.930 --> 00:01:07.760
大きい 3 は 2 番目にきます

00:01:09.270 --> 00:01:12.850
次のペアに移動して
同じように比較します

00:01:12.850 --> 00:01:15.509
7 は 0 より大きいので

00:01:15.510 --> 00:01:19.370
最初のスポットに 0
2 番目のスポットに 7 を書き入れます

00:01:21.200 --> 00:01:25.291
最後の要素である 10 と
2 を比較し

00:01:25.291 --> 00:01:27.229
新しい配列に
順番に並べます

00:01:29.700 --> 00:01:30.940
簡単でしたね

00:01:30.940 --> 00:01:34.690
そして最後に実行するのは
比較回数のトラッキングです

00:01:34.690 --> 00:01:39.500
この効率を計算するときに
全体の効率計算を実行する際に

00:01:39.500 --> 00:01:43.130
このステップにもどれるように比較の回数
3 と緑で記入しておきます

00:01:44.590 --> 00:01:46.230
スペースがなくなってきたので

00:01:46.230 --> 00:01:49.548
最後の列を残して
上に移動します

00:01:49.548 --> 00:01:54.530
次は前半の 2 配列と
後半の 2 配列を組み合わせ

00:01:54.530 --> 00:01:58.380
それぞれ 3 列と 4 列の
配列を作成します

00:01:59.790 --> 00:02:02.900
これらの比較は
少し複雑です

00:02:03.210 --> 00:02:06.770
1 要素の配列と 2 要素の配列を
比較します

00:02:08.150 --> 00:02:11.450
右側の配列はすでに
ソート済みであることが分かってます

00:02:11.450 --> 00:02:15.399
新しい配列の最初の要素は
こちらまたはこの配列の最初の要素から

00:02:15.400 --> 00:02:16.840
ここに記入します

00:02:18.390 --> 00:02:21.179
1 がより小さいので
最初の要素になります

00:02:22.630 --> 00:02:25.260
この配列の次の要素に移動して
それとこの要素を

00:02:25.260 --> 00:02:26.299
比較します

00:02:27.840 --> 00:02:31.300
3 は 8 より小さいので
このボックスには 3 を記入します

00:02:32.900 --> 00:02:36.160
この配列は完了したので
もう一つの配列の残りを

00:02:36.160 --> 00:02:38.400
この配列の最後に
記入します

00:02:39.910 --> 00:02:41.680
できました。ではこの配列の
構築に移ります

00:02:43.600 --> 00:02:47.299
これらの配列の最初の
2 つの要素の比較から始めます

00:02:47.300 --> 00:02:49.320
つまり 0 と 2 です

00:02:49.320 --> 00:02:55.124
0 は 2 よりも小さいので
新しい配列の最初の要素は 0 になります

00:02:55.124 --> 00:03:01.670
では次は、この配列の次の要素である
7 とこちらの 2 を

00:03:01.670 --> 00:03:02.825
比較します

00:03:02.825 --> 00:03:04.886
2 は 7 より小さいので
新しい配列には 2 を記入します

00:03:06.577 --> 00:03:09.257
この手順を繰り返して
7 と 10 を比較し

00:03:09.257 --> 00:03:11.187
順番に配列に
記入します

00:03:12.867 --> 00:03:15.797
このステップでは
何度比較を実行しましたか

00:03:15.797 --> 00:03:21.270
数えてみると 5 回なので
パープルで 5 と記入しておきます

00:03:21.270 --> 00:03:22.487
完成まであと一歩です

00:03:22.487 --> 00:03:25.107
配列のソートを完了するには
もう 1 回ソートを

00:03:25.107 --> 00:03:25.767
実行する必要があります

00:03:27.400 --> 00:03:29.370
前のラウンドと同様の
手順を開始します

00:03:30.660 --> 00:03:35.400
2 つの配列の最初の 2 つの要素の
比較から始めます

00:03:35.400 --> 00:03:37.250
つまり 1 と 0 です

00:03:37.250 --> 00:03:41.140
0 が小さいのでこの配列の端に
記入し、古い配列から

00:03:41.140 --> 00:03:42.670
削除します

00:03:44.170 --> 00:03:49.399
次に 1 と 2 を比較して
小さい方を記入します

00:03:49.400 --> 00:03:52.571
つまりこのスポットは 1 です

00:03:52.571 --> 00:03:56.840
次に 2 と 3 を比較し
次は 3 と 7 の比較を繰り返します

00:03:56.840 --> 00:04:02.570
そして 8 と 7 を比較し

00:04:04.800 --> 00:04:06.250
これで終了です

00:04:06.250 --> 00:04:07.730
新たにソートされた配列が完成しました

00:04:09.260 --> 00:04:12.970
このステップで行った比較の回数を
トラッキングする必要があります

00:04:12.970 --> 00:04:15.650
横に 6 回と
記入します

