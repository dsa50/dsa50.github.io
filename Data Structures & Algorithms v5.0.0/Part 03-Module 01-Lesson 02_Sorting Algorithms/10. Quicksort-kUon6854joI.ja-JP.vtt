WEBVTT
Kind: captions
Language: ja-JP

00:00:00.490 --> 00:00:05.740
クイックソートは多くの場合
最も効率的なソートアルゴリズムです

00:00:05.740 --> 00:00:08.830
クイックソートを実行するには
配列から適当に

00:00:08.830 --> 00:00:10.390
値を 1 つ選択します

00:00:10.390 --> 00:00:16.129
その値より大きな値はすべてその後方に
小さな値は前方に移動させます

00:00:16.129 --> 00:00:18.230
最初に選んだ値は
ピボットと呼ばれます

00:00:19.920 --> 00:00:24.170
配列の前方と後方セクションから
それぞれピボットを選択し

00:00:24.170 --> 00:00:29.660
配列全体がソートされるまで
再帰的に同様のソートを行います

00:00:29.660 --> 00:00:31.100
では、実際に見てみましょう

00:00:32.180 --> 00:00:34.580
まず、ピボットを選択する必要があります

00:00:34.580 --> 00:00:37.320
最後の要素を
ピボットとして選ぶのが慣例です

00:00:37.320 --> 00:00:38.489
その方法で実行してみましょう

00:00:40.360 --> 00:00:43.890
最初の要素は
ピボットより大きいので

00:00:43.900 --> 00:00:45.850
ピボットの後ろに移動させます

00:00:45.850 --> 00:00:48.000
ただし in-place ソートを実行しているので

00:00:48.000 --> 00:00:51.240
スペースを確保するために
ピボットの前の要素を移動させる必要があります

00:00:52.410 --> 00:00:55.230
したがって、このステップでは
8 を最後のブロックに

00:00:55.230 --> 00:00:59.870
2 を後から 2 番目のブロックに
10 を最初のブロックに移動させます

00:01:00.920 --> 00:01:02.566
ちょっと直感に反するように思えます

00:01:02.566 --> 00:01:07.500
10 を移動するなら前ではなく
後ろではないかと思いませんか

00:01:07.500 --> 00:01:09.960
この問題はひとまず保留して
後でなぜこれが機能するかを見ていきます

00:01:11.620 --> 00:01:15.190
移動が完了したら
比較を実行できます

00:01:15.190 --> 00:01:17.107
では 10 に注目してみましょう

00:01:17.107 --> 00:01:21.380
10 は 2 より大きいので
再び 10 を後ろに移動させます

00:01:21.380 --> 00:01:24.330
2 をアップして 2 の前の値を
同様にアップさせます

00:01:25.330 --> 00:01:26.649
そしてもう 1 回入れ替えをします

00:01:27.910 --> 00:01:30.679
最終的に 0 が
配列の先頭にきて

00:01:30.680 --> 00:01:33.670
これはピボット 2 より
小さくなります

00:01:33.670 --> 00:01:36.510
よくできましたが 2 番目の要素を
移動させて同じプロセスを

00:01:36.510 --> 00:01:38.760
実行します

00:01:38.760 --> 00:01:42.380
3 は 2 より大きいので
再度すべてをシフトする必要があります

00:01:43.380 --> 00:01:45.259
これでずっとよくなりました

00:01:46.690 --> 00:01:50.270
7 は 2 より大きいので
別の比較が必要です

00:01:51.610 --> 00:01:52.900
これは必要な入れ替えです

00:01:54.700 --> 00:01:55.740
そして配列は
こうなります

00:01:56.840 --> 00:01:58.745
なかなかいい感じです

00:01:58.745 --> 00:02:00.110
2 は正しい位置にあります

00:02:00.110 --> 00:02:03.440
この前にある要素をチェックして
すべてがこれより小さくないことを確認します

00:02:03.440 --> 00:02:06.270
そして後ろの要素はすべて
これよりも確実に大きな値であることを

00:02:06.270 --> 00:02:07.289
確認します

00:02:07.290 --> 00:02:10.700
配列で 2 の前にある
すべての要素は

00:02:10.700 --> 00:02:14.680
2 よりも小さく
2 の後ろにある要素は

00:02:14.680 --> 00:02:18.500
すべて 2 より大きいと確認することで
2 が正しい位置にあることが分かります

00:02:18.500 --> 00:02:21.800
さらなる移動が不要なことが分かるよう
これにカラーを付けます

00:02:21.800 --> 00:02:24.150
この時点でピボットより
小さなすべての値と

00:02:24.150 --> 00:02:28.100
大きなすべての値について
同じ処理を行います

00:02:28.100 --> 00:02:30.690
小さい値から始めましょう。

00:02:30.690 --> 00:02:33.940
ピボットを選択して
前の値と比較します

00:02:33.940 --> 00:02:37.870
0 は 1 よりも小さいので
何もする必要はありません

00:02:37.870 --> 00:02:39.360
そして 1 回比較をしただけで

00:02:39.360 --> 00:02:43.300
値がすべて正しい位置にあることが分かったので
次に行きます

00:02:43.300 --> 00:02:45.910
次は配列の残り半分を処理するので
まずピボット選択します

00:02:46.950 --> 00:02:51.399
7 と 3 はピボットより小さいので
移動させる必要はありません

00:02:51.400 --> 00:02:53.390
ですがこれはピボットより大きいので

00:02:53.390 --> 00:02:55.660
入れ替える必要があります

00:02:55.660 --> 00:02:58.487
入れ替えはこれで完了です
8 と 10 が

00:02:58.487 --> 00:03:01.970
最終的な位置に
納まりました

00:03:01.970 --> 00:03:06.179
8 より小さな値はすべて
8 の前にあるのでこれ以上の移動は不要です

00:03:06.179 --> 00:03:11.260
ですがおそらくソートが必要な要素が
2 つ残っています

00:03:11.260 --> 00:03:14.980
ここでは 3 をピボットに割り当て
再度比較を実行します

00:03:16.130 --> 00:03:18.109
この 2 つの値を入れ替える
必要があることがわかります

00:03:18.110 --> 00:03:21.200
これを入れ替えれば
配列全体のソートが完了です

