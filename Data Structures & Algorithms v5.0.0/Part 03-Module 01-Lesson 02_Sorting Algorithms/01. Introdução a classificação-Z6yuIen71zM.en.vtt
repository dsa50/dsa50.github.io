WEBVTT
Kind: captions
Language: en

00:00:00.520 --> 00:00:02.940
Let's move on to sorting algorithms.

00:00:02.940 --> 00:00:06.200
In a search algorithm you
have some kind of list, and

00:00:06.200 --> 00:00:07.600
you're just checking out each element.

00:00:08.850 --> 00:00:12.590
However, in a sorting algorithm
you're changing the order of elements

00:00:12.590 --> 00:00:13.120
in an array.

00:00:14.240 --> 00:00:17.570
Let's say you wanted to
sort these guys by height.

00:00:17.570 --> 00:00:20.100
You have some decisions to make first.

00:00:20.100 --> 00:00:24.600
Should I put the shortest element
on this end or on this end?

00:00:24.600 --> 00:00:26.900
And what algorithm should I use to sort?

00:00:27.360 --> 00:00:30.450
You could just compare every
element to every other element

00:00:30.450 --> 00:00:32.820
until you have everything in order.

00:00:32.820 --> 00:00:36.200
This is called the naive approach
since there is no real trick or

00:00:36.200 --> 00:00:37.500
cool algorithm involved there.

00:00:38.650 --> 00:00:42.570
The naive approach is normally the first
thing your mind skips to when you see

00:00:42.570 --> 00:00:43.160
a new problem.

00:00:44.420 --> 00:00:48.520
It makes you think I know I could do it
this way and everything's going to be

00:00:48.520 --> 00:00:51.710
right, but there's probably
a smarter way to do this.

00:00:52.750 --> 00:00:55.350
Sorting is kind of a weird topic.

00:00:55.350 --> 00:00:58.500
You'll rarely be given a problem
that can't be solved with

00:00:58.500 --> 00:01:00.360
one of the classic sorting
algorithms we go through here.

00:01:01.790 --> 00:01:05.310
As far as interviews are concerned,
it's important to understand how sorting

00:01:05.310 --> 00:01:08.420
algorithms work and
have their run times memorized so

00:01:08.420 --> 00:01:11.200
you can answer complexity
problems really fast.

00:01:12.400 --> 00:01:15.200
Lastly, you should make sure you've
considered whether your sorting

00:01:15.200 --> 00:01:17.400
algorithm is in place or not.

00:01:18.200 --> 00:01:21.130
An in place sorting algorithm
just rearranges the elements

00:01:21.130 --> 00:01:24.640
in the data structure they're
already in without needing to copy

00:01:24.640 --> 00:01:26.430
everything to a new data structure.

00:01:27.430 --> 00:01:29.990
These algorithms have
low space complexity

00:01:29.990 --> 00:01:31.979
because you don't need to
recreate the data structure.

00:01:33.390 --> 00:01:37.190
Often you'll have that classic
tradeoff when you use less space or

00:01:37.190 --> 00:01:37.920
use less time.

00:01:39.600 --> 00:01:42.900
It doesn't really matter for
arrays with ten numbers, but

00:01:42.900 --> 00:01:46.400
if you have millions or billions of
data points it makes a huge difference.

00:01:47.800 --> 00:01:49.660
It'll never hurt to mention
that in an interview.

00:01:49.660 --> 00:01:53.840
You can pick one way or the other,
but say why you're doing so.

00:01:53.840 --> 00:01:56.880
The more reasons you can provide for
your choices, the smarter you seem.

