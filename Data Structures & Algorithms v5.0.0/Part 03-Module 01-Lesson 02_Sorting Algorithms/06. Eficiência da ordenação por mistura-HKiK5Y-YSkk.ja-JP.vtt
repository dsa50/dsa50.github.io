WEBVTT
Kind: captions
Language: ja-JP

00:00:00.590 --> 00:00:03.880
全体的に何度比較を
行いましたか

00:00:03.880 --> 00:00:06.680
ここでパターンを検証しましょう

00:00:06.680 --> 00:00:08.500
各ステップで

00:00:08.500 --> 00:00:12.510
構築した配列より
1 つ少ない数の比較を実行しました

00:00:12.510 --> 00:00:17.300
つまり 7 配列を構築していたら
6 回の比較を実行したことになります

00:00:17.300 --> 00:00:21.586
3 配列なら
比較は 2 回で、2 配列なら

00:00:21.586 --> 00:00:25.299
比較は 1 回。4 配列なら
比較を 3 回実行しました

00:00:26.430 --> 00:00:27.580
先に進みますが

00:00:27.580 --> 00:00:31.259
わかりやすくするために
各配列の長さを m で表します

00:00:32.409 --> 00:00:36.510
m が構築している
配列のサイズなら

00:00:36.510 --> 00:00:40.440
比較の回数は常に
それより 1 少なくなります

00:00:40.440 --> 00:00:44.470
ここで比較の正確な回数を
割り出すのは簡単ではありません

00:00:44.470 --> 00:00:49.120
ですが頼りになる
近似と呼ばれる概念があります

00:00:49.120 --> 00:00:52.379
すべての繰り返しにおいて
同じ 7 つの要素を

00:00:52.380 --> 00:00:56.730
何度も反復することが分かっているので
配列のサイズ (長さ)

00:00:56.730 --> 00:01:01.500
つまり m は常に
最後は 7 になります

00:01:01.500 --> 00:01:03.989
ここを再度ご覧ください
配列は 7 です

00:01:03.990 --> 00:01:08.191
ここは 4 配列と 3 配列を足して
合計 7 になります

00:01:08.191 --> 00:01:12.370
ここは 1、2、2、2 配列を足すと
やはり 7 です

00:01:13.410 --> 00:01:14.780
分割統治法の概念を使って

00:01:14.780 --> 00:01:18.780
各ステップで配列を分割しているので
各ステップにおいて

00:01:18.780 --> 00:01:21.400
ほぼ 7 回の比較を
実行していると言うことができます

00:01:22.380 --> 00:01:24.240
ここでは 7 が上限です

00:01:24.240 --> 00:01:27.390
7 回を超える比較は
行いませんが

00:01:27.390 --> 00:01:29.260
ステップごとに 7 に近くなっています

00:01:30.740 --> 00:01:34.890
ソートアルゴリズムの実行回数を
明らかにするためには

00:01:34.890 --> 00:01:40.370
繰り返しのたびに全体的な反復回数に
比較回数を乗算します

00:01:40.370 --> 00:01:44.940
バブルソートでは
n 回の比較と n ステップを実行していました

00:01:44.940 --> 00:01:48.750
これはステップごとに最大 n 回の比較を
実行したことを証明したにすぎません

00:01:49.940 --> 00:01:52.500
全体的には何ステップを実行しているのでしょうか

00:01:53.180 --> 00:01:55.735
では 7 配列をソートするには

00:01:55.735 --> 00:02:00.600
1、2、3 という
3 ステップが必要でした

00:02:01.600 --> 00:02:04.475
ここで発生する
サブプロセスには注意が必要です

00:02:05.485 --> 00:02:09.520
この 2 配列をソートするために
実行する必要があるのは 1 ステップのみ

00:02:11.140 --> 00:02:13.455
3 配列または 4 配列を
ソートする場合は

00:02:13.455 --> 00:02:17.550
2 ステップを
実行する必要がありました

00:02:17.550 --> 00:02:20.295
これらをトラッキングするために
テーブルを使用できます

00:02:20.295 --> 00:02:25.350
確認すると、配列の長さが 7 の場合
異なる 3 ステップを実行する必要がありました

00:02:25.350 --> 00:02:30.230
配列の長さが 3 または 4 の場合
2 ステップを実行する必要がありました

00:02:30.230 --> 00:02:33.852
配列の長さが 2 の場合
実行すべきは 1 ステップです

00:02:33.853 --> 00:02:38.500
要素が 1 つしかない場合は
比較は必要ないため 0 ステップです

00:02:39.342 --> 00:02:43.600
ここに今から
いくつかの数字を入力したいと思います

00:02:43.600 --> 00:02:46.420
私自身も計算をしますので
皆さんも

00:02:46.420 --> 00:02:48.609
ご自分で計算してみてください

00:02:48.610 --> 00:02:52.100
できました。これらの数字に
見覚えがあるのではないでしょうか

00:02:52.100 --> 00:02:56.300
バイナリーサーチに
類似したテーブルがあり

00:02:56.300 --> 00:03:00.700
2 をステップ数乗じるたびに
反復回数が増加していました

00:03:00.700 --> 00:03:03.679
ここにも非常に類似した
傾向が見られます

00:03:03.679 --> 00:03:05.912
2 をステップ数乗したときに
増加する代わりに

00:03:05.912 --> 00:03:08.845
今回は 2 をステップ数乗したその後に
1 ずつ増加しています

00:03:08.845 --> 00:03:11.137
[BLANK_AUDIO]

00:03:11.137 --> 00:03:13.540
バイナリーサーチのビデオでは

00:03:13.540 --> 00:03:16.850
反復回数が
log(n) と等しくなる理由を証明しました

00:03:16.850 --> 00:03:18.810
再確認が必要であれば
そのビデオを見直してください

00:03:20.550 --> 00:03:23.230
今回は 2 をステップ数乗じたときに
増加するのではなく

00:03:23.230 --> 00:03:26.220
2 をステップ数乗した後に増加する点が
少し違います

00:03:26.220 --> 00:03:29.765
ここでも役に立つのは
近似という概念です

00:03:29.765 --> 00:03:33.665
変化が起こっている間隔が
把握できれば

00:03:33.665 --> 00:03:36.655
変化が起きている場所は
関係ありません

00:03:38.195 --> 00:03:45.594
要約するとだいたい
log(n) ステップで n 回の比較を実行します

00:03:45.594 --> 00:03:49.236
これによって nlog(n) の
全体的な複雑さが分かります

00:03:49.236 --> 00:03:52.570
これはバブルソートでの
n 乗よりも遥かに優れています

00:03:53.610 --> 00:03:58.640
バブルソートでは効率として
n 掛ける n または n の 2 乗を実行しました

00:04:00.105 --> 00:04:02.840
log(n) は一般的には
n より小さな値になりますが

00:04:02.840 --> 00:04:05.650
n よりも大きくなることは
絶対にありません

00:04:05.650 --> 00:04:08.450
よってマージソートの効率が
バブルソートの効率よりも

00:04:08.450 --> 00:04:09.750
良いと言えます

00:04:11.800 --> 00:04:15.800
ですがマージソートのスペース効率は
バブルソートに劣ります

00:04:16.260 --> 00:04:18.630
バブルソートでは
所定の位置でソートを実行していたので

00:04:18.630 --> 00:04:20.690
追加の配列を使用する必要はありませんでした

00:04:21.860 --> 00:04:24.770
ここでは新しい配列に
値をコピーしていました

00:04:26.500 --> 00:04:32.420
使用した補助的または余分なスペースは
線形だったと言えます

00:04:32.420 --> 00:04:36.909
この複雑性は使用後に
これらの配列を削除したと仮定します

00:04:36.909 --> 00:04:40.605
各ステップで値を
新しい列にコピーしていたので

00:04:40.605 --> 00:04:42.926
ある時点で新しい配列が必要でした

00:04:42.926 --> 00:04:46.195
ですがソートが完了したら
古い配列は削除していたと

00:04:46.196 --> 00:04:47.340
言えるでしょう

00:04:47.340 --> 00:04:49.940
つまり毎回多数の
配列を使用していたわけではありません

00:04:49.940 --> 00:04:54.210
ステップごとに
2 つの異なる配列のみが必要です

00:04:54.210 --> 00:04:57.400
しれは数値を入力する配列と
値をコピーする配列です

