WEBVTT
Kind: captions
Language: ja-JP

00:00:00.830 --> 00:00:04.149
ではこのアルゴリズムの
効率はどうでしょうか

00:00:04.150 --> 00:00:08.760
これまで何度も配列全体について
検証する必要がありました

00:00:08.760 --> 00:00:10.640
これは今までの概略です

00:00:10.640 --> 00:00:14.823
全体的に 4 回または
n-1 回の反復と

00:00:14.823 --> 00:00:18.690
各ステップで n-1 回の比較を実行しました

00:00:18.690 --> 00:00:26.630
n-1 回の比較と n-1 回の反復は
このように表せます

00:00:26.630 --> 00:00:29.730
では代数を使って
何を簡略化するのか確認します

00:00:31.280 --> 00:00:33.640
するとこのような式に
なります

00:00:33.640 --> 00:00:36.840
代数を使えなくても
心配する必要はありません

00:00:36.840 --> 00:00:39.420
マイナス 1 はそれほど変化を
与えませんが

00:00:39.420 --> 00:00:42.380
n 掛ける n または二乗という
計算は常に実行できます

00:00:43.670 --> 00:00:49.440
つまりこの -2n+1 は
必要ありません

00:00:49.440 --> 00:00:50.800
これは削除できます

00:00:50.800 --> 00:00:54.980
すると残ったのは
効率的な O(n2) です

00:00:56.200 --> 00:00:58.920
実際にこのアルゴリズムを使うと
いくらかの時短が

00:00:58.920 --> 00:00:59.940
実現されます

00:00:59.940 --> 00:01:04.800
お気づきかもしれませんが
配列を検証する際

00:01:04.800 --> 00:01:07.960
絶対必要ではない
最後のいくつかの値の比較も実行していました

00:01:07.960 --> 00:01:11.390
7 をバブルアップさせるために
7 と 8 を比較することは理にかなっています

00:01:11.400 --> 00:01:15.380
ですがこれらより小さな数字を
バブルアップさせる場合

00:01:15.380 --> 00:01:18.560
この比較は
何ら影響を与えません

00:01:18.560 --> 00:01:22.220
最も一般的なバブルソートでは
この最後の数字の比較というステップは

00:01:22.220 --> 00:01:26.400
必要性がない場合は
省略されます

00:01:26.400 --> 00:01:29.330
最初の反復の後
8 が正しい場所にあることが

00:01:29.330 --> 00:01:30.410
分かっていると仮定します

00:01:30.410 --> 00:01:33.600
つまり、他の比較後に
再度確認する必要はないのです

00:01:33.600 --> 00:01:35.399
これはいくらかの時間を節約しますが

00:01:35.400 --> 00:01:39.320
O(n2) のランタイム全体に
変化を与えるものではありません

00:01:39.320 --> 00:01:43.250
いくつかの注意点を
述べておきます

00:01:43.250 --> 00:01:45.250
最悪のケースと平均的なケースはともに

00:01:45.250 --> 00:01:47.610
O(n2) になることは
理解しました

00:01:48.850 --> 00:01:52.590
ですが最良のケースは
O(n) で表されます

00:01:52.600 --> 00:01:55.700
最良のケースはすでに配列の
ソートが完了しており

00:01:55.700 --> 00:02:00.310
ソート済みの配列を確認する以外
他に何もする必要がない場合

00:02:00.310 --> 00:02:04.600
または配列の 1 つの数字のみを
新しい位置にバブルアップさせる場合です

00:02:04.600 --> 00:02:09.370
そしてソートを実行するうえで
他に何もする必要がありませんでした

00:02:09.370 --> 00:02:13.410
追加の配列や追加のデータ構造
そういったものすべてです

00:02:13.410 --> 00:02:17.400
バブルソートは in-place アルゴリズムの
良い例であり

00:02:17.400 --> 00:02:20.300
空間複雑性は定数です

00:02:20.300 --> 00:02:24.100
これは全体的なプロセスで追加配列や
データ構造が不要であることを意味します

