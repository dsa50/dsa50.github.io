WEBVTT
Kind: captions
Language: ja-JP

00:00:00.800 --> 00:00:04.734
より具体的なバイナリーの一種として
二分探索木と呼ばれるものがあります

00:00:04.734 --> 00:00:10.690
二分探索木、略してBSTは
もちろんバイナリーツリーです

00:00:10.690 --> 00:00:14.219
つまり、すべての親ノードには
最大 2 つの子があります

00:00:14.220 --> 00:00:20.700
しかし配列はある種のリストであるため
BST はバイナリーツリーの一種にすぎません

00:00:20.700 --> 00:00:21.490
各ノードに関連する

00:00:21.490 --> 00:00:25.430
値の配置方法について
ある特定のルールがあります

00:00:25.430 --> 00:00:30.000
BST は特定ノードの
左にある値がより小さく

00:00:30.100 --> 00:00:34.739
右にある値がより大きくなるよう
ソートされています

00:00:34.739 --> 00:00:39.714
この BST のストラクチャーにより
探索や挿入、削除などの操作を

00:00:39.715 --> 00:00:41.580
かなり迅速に行うことができます

00:00:41.580 --> 00:00:43.259
たとえば 7 を探索する場合

00:00:43.259 --> 00:00:45.340
まずはルートから始めます

00:00:45.340 --> 00:00:49.200
7 は 5 より大きいので
次に進みます

00:00:49.200 --> 00:00:52.730
次の要素は 8 なので
次は左に進むことがわかっています

00:00:52.730 --> 00:00:55.290
ほんの数ステップで 7 を見つけることができました

00:00:55.290 --> 00:00:58.900
お気付きかもしれませんが
目的の要素を見つけるために

00:00:58.900 --> 00:01:01.170
すべての要素を探索する
必要はありませんでした

00:01:01.170 --> 00:01:04.680
確認する必要があるのは
ツリーの各レベルの 1 つの値のみで

00:01:04.680 --> 00:01:08.130
要素と比較するだけで
判断を下すことが可能です

00:01:08.130 --> 00:01:12.690
つまり BST 上での探索の実行時間は
ツリーの高さだということです

00:01:12.690 --> 00:01:16.220
これは挿入について学習した際に
log(n) であることが証明されています

00:01:16.220 --> 00:01:20.300
バイナリーツリーでの挿入も
ほぼ同じプロセスです

00:01:20.300 --> 00:01:23.960
まずは一番上からスタートし
追加したい要素を比較しながら

00:01:23.960 --> 00:01:27.169
各ステップでどちらに進むか
すばやく判断します

00:01:27.170 --> 00:01:29.430
最終的にはツリーの
空白スポットにヒットします

00:01:30.530 --> 00:01:34.100
各ステップで要素を
正しく比較していさえすれば

00:01:34.100 --> 00:01:38.310
主要な BST のプロパティに違反することなく
新しい要素をここに配置できます

00:01:39.650 --> 00:01:42.180
削除はさらに少し複雑です

00:01:43.280 --> 00:01:46.820
ですが、一般的なバイナリーツリーの場合でも
同様に複雑なため

00:01:46.820 --> 00:01:50.710
さまざまなケースについて
この解がやはり適用されます

