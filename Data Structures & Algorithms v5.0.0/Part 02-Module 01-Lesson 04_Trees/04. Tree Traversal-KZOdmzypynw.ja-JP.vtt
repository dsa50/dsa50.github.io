WEBVTT
Kind: captions
Language: ja-JP

00:00:00.190 --> 00:00:04.280
リストデータ構造を見ると
トラバースはとても単純でした

00:00:04.280 --> 00:00:07.210
すべての要素を
確認するために

00:00:07.210 --> 00:00:09.710
リスト全体を検証する必要がありました

00:00:09.710 --> 00:00:14.135
ツリー構造は線形ではないので
すべてをトラバースする方法が明確ではありません

00:00:14.135 --> 00:00:18.655
ルートから開始する場合
左右どちらから始めるか

00:00:18.655 --> 00:00:21.905
親やすべての子ノードを含め
1 つのサブツリーや

00:00:21.905 --> 00:00:26.522
ツリーの 1 セクションを
完全にトラバースすべきか

00:00:26.522 --> 00:00:29.671
または同じレベルをまず
トラバースすべきなのか

00:00:29.672 --> 00:00:34.512
ツリー構造におけるトラバースは
少し複雑ですがどれも重要です

00:00:34.512 --> 00:00:38.102
最初にすべての要素にアクセスできる方法を
確認しない限り

00:00:38.102 --> 00:00:40.220
要素の検索やソートはできません

00:00:40.220 --> 00:00:43.242
トラバース処理には
2 つの異なるアプローチがあります

00:00:43.242 --> 00:00:47.532
1 つ目は深さ優先探索
短縮して DFS と呼ばれます

00:00:47.532 --> 00:00:52.639
DFS の原則は
探索する子ノードがある場合

00:00:52.640 --> 00:00:55.150
まずはそれらを探索するのが
最優先です

00:00:55.150 --> 00:00:58.410
これが何を意味するのかは
後ほど詳しく見てきます

00:00:58.410 --> 00:01:02.540
別の手法は
幅優先探索 (BFS) と呼ばれます

00:01:02.540 --> 00:01:07.120
BFS では子ノードを探索する前に
現在同じレベルにあるすべてのノードを

00:01:07.120 --> 00:01:10.100
優先して探索します

00:01:10.100 --> 00:01:15.430
BFS と DFS の定義は曖昧です
というのも、それらの原則は適用できますが

00:01:15.430 --> 00:01:18.640
実際のツリー構造のトラバースには
いくつかの異なる方法があるからです

00:01:18.640 --> 00:01:19.540
ツリーの場合

00:01:19.540 --> 00:01:25.290
レベル順のトラバースは
正確なアルゴリズムを持つ BFS です

00:01:25.290 --> 00:01:28.280
レベル順トラバースは
まさにその通りの動作です

00:01:29.300 --> 00:01:33.910
ルートから開始して
2 番目のレベルの子ノードに移動し

00:01:33.910 --> 00:01:38.630
それから 3 番目のレベルというように
すべての葉を探索します

00:01:38.630 --> 00:01:42.550
通常、レベルの最も左にあるノードから
右へと移動します

00:01:42.550 --> 00:01:45.390
このトラバースは紛れもない BFS です

00:01:45.400 --> 00:01:48.880
子ノードに移動する前に
同レベルのすべてのノードを探索します

