WEBVTT
Kind: captions
Language: ja-JP

00:00:00.190 --> 00:00:00.960
そうですね

00:00:00.960 --> 00:00:04.750
まず、どのような入力の
可能性があるのか考えてみます

00:00:04.750 --> 00:00:08.200
none または空の行列を入力
として取得した場合

00:00:08.200 --> 00:00:10.490
0 を返すことになります

00:00:10.500 --> 00:00:14.280
ここにはアイランドが
ないことが確かですが

00:00:14.280 --> 00:00:16.990
これが入力の可能性もあります

00:00:16.990 --> 00:00:20.639
そこで、最初の要素から
検討してみたいと思います

00:00:20.640 --> 00:00:21.670
最初の要素は 1 なので

00:00:21.670 --> 00:00:24.120
アイランドカウンター変数
(バリアブル) を使って

00:00:24.120 --> 00:00:26.960
この要素を初期化し
1 ずつインクリメントします

00:00:26.960 --> 00:00:28.590
ここに 0 があり

00:00:28.590 --> 00:00:30.875
これはアイランドの一部ではないので

00:00:30.875 --> 00:00:32.270
ここでは何もする
ことがありません

00:00:32.270 --> 00:00:33.990
よって次の要素に移ります

00:00:36.180 --> 00:00:39.600
これは同じアイランドの一部なので

00:00:39.600 --> 00:00:44.180
1 が同じアイランドのどの部分
なのかを追跡する必要があります

00:00:47.200 --> 00:00:51.100
おそらくここですべきことは
上下の要素を確認して

00:00:51.100 --> 00:00:55.300
これらが同じアイランドの
一部であるか検証し

00:00:55.300 --> 00:00:57.446
何らかの方法で追跡することです

00:00:57.446 --> 00:01:02.400
そうですね、そのアプローチ自体は
悪くありませんが、たとえば最初の要素の

00:01:02.400 --> 00:01:06.350
下には要素がありますが
上にはありませんよね

00:01:06.350 --> 00:01:08.000
この場合、どうしますか

00:01:08.000 --> 00:01:11.800
&gt;&gt; 上に要素がないので
おそらく何らかの

00:01:11.800 --> 00:01:12.929
ランタイムエラーが生じると思われます

00:01:12.930 --> 00:01:15.670
ということは、上の要素が 1 か 0 かを
確認する前にまず上に要素が

00:01:15.670 --> 00:01:19.737
存在するかどうかを
確認しなければなりません

00:01:22.570 --> 00:01:24.625
そのため、何らかの方法で
これを追跡します

00:01:24.625 --> 00:01:27.670
もしかするとこれは
データ構造なのかもしれません

00:01:27.670 --> 00:01:30.110
&gt;&gt; そうですね、このアプローチや
この問題、あるいはこれまでの

00:01:30.110 --> 00:01:32.940
手順を振り返ってみて
何か思い当たることはありませんか

00:01:32.940 --> 00:01:36.900
&gt;&gt; はい、この行列は表として
表現することができます

00:01:36.900 --> 00:01:38.900
ということは幅優先探索
かもしれません

00:01:38.900 --> 00:01:41.240
だとすると、最初の要素の
前後を確認して

00:01:41.240 --> 00:01:45.160
それらの要素をキューに
追加してみます

00:01:45.160 --> 00:01:49.390
これらの要素が 1 かどうか確認し
1 である場合は別の数字に設定して

00:01:49.400 --> 00:01:51.700
これらの要素を確認済みとして
マークします

00:01:51.700 --> 00:01:53.169
これで先に進めます

00:01:53.170 --> 00:01:54.250
&gt;&gt; いいですね

00:01:56.140 --> 00:01:59.370
&gt;&gt; この面接ではテストケースが
ブレインストーミングに

00:01:59.370 --> 00:02:00.370
役立ったようですね

00:02:00.370 --> 00:02:01.200
&gt;&gt; そうですね

00:02:02.650 --> 00:02:07.360
&gt;&gt; テストケースを使うことで解答に
一歩近づくことができました

00:02:07.360 --> 00:02:10.340
面接官とのコミュニケーションが
よく取れていたのも

00:02:10.340 --> 00:02:11.670
よかったと思います

00:02:11.670 --> 00:02:14.859
与えられたヒントから正解に辿り着く
ことができましたね

00:02:15.950 --> 00:02:19.369
&gt;&gt; はい、面接官は自分の味方ではないと
思っている人が多いかもしれませんか

00:02:19.370 --> 00:02:21.900
実はそうではありません

00:02:21.900 --> 00:02:24.390
必要に応じて手助けをするのが
面接官の役目であり

00:02:24.390 --> 00:02:28.799
相手のフィードバックを受け入れるかどうかで
チームワーク力が評価されることもあります

00:02:28.800 --> 00:02:31.420
もちろん問題の解決にも
つながりますしね

00:02:31.420 --> 00:02:34.109
面接の場では緊張のあまりに
面接官の話が頭に入らず

00:02:34.110 --> 00:02:37.720
提案を無視してしまう
ことがあります

00:02:37.720 --> 00:02:40.370
これは大きなマイナス
ポイントです

00:02:40.370 --> 00:02:44.170
では、テストケースやエッジケースを
使っても問題を解けない場合は

00:02:44.170 --> 00:02:45.140
どうすればよいでしょうか

00:02:45.140 --> 00:02:49.490
&gt;&gt; 彼の場合は幅優先探索
アルゴリズムを思い出したことで

00:02:49.500 --> 00:02:51.510
軌道修正できました

00:02:51.510 --> 00:02:54.739
回答に行き詰まってしまったときは
どのようなアルゴリズムや

00:02:54.740 --> 00:02:58.210
データ構造が考えられるのか
ブレインストーミングしてみましょう

00:02:58.210 --> 00:03:02.240
この例では、グラフは行列で表現できること
このケースは幅優先探索に当てはまることに

00:03:02.240 --> 00:03:04.690
気付けたことが
正解につながったようですね

