WEBVTT
Kind: captions
Language: ja-JP

00:00:01.500 --> 00:00:04.370
そこで主な関数をアイランド
カウンターと呼ぶことにして

00:00:04.370 --> 00:00:06.800
ここに行列を取り込みます

00:00:06.800 --> 00:00:11.280
まず none を考慮する
必要があるので

00:00:11.280 --> 00:00:18.262
この行列が none と等しい場合や

00:00:18.262 --> 00:00:25.513
空の行列と等しい場合

00:00:25.513 --> 00:00:33.957
[無音]

00:00:33.957 --> 00:00:36.535
この例ではすぐに
0 を返すことにします

00:00:36.535 --> 00:00:40.708
[無音]

00:00:40.708 --> 00:00:45.385
該当しない場合は
アイランド変数 (バリアブル) を

00:00:45.386 --> 00:00:50.700
アイランドの数である
0 に初期化します

00:00:50.700 --> 00:00:54.200
そしてこれをループする
2 つの for ループを実行します

00:00:54.200 --> 00:00:58.962
ここで行と列の数が
必要となります

00:00:58.962 --> 00:01:08.962
[無音]

00:01:16.685 --> 00:01:18.130
すみません、上下が逆でした

00:01:20.490 --> 00:01:22.494
次に for ループを記述します

00:01:22.495 --> 00:01:32.495
[無音]

00:01:47.767 --> 00:01:53.650
この段階で要素が 1 と
等しいか確認します

00:01:53.650 --> 00:02:03.650
[無音]

00:02:05.586 --> 00:02:10.148
等しい場合はアイランドカウントを
インクリメントします

00:02:10.148 --> 00:02:16.457
[無音]

00:02:16.457 --> 00:02:18.520
ここで先ほど話した

00:02:18.520 --> 00:02:21.790
幅優先探索を行う
必要があるので

00:02:21.790 --> 00:02:24.403
ヘルパーメソッドを実行します

00:02:24.403 --> 00:02:32.891
[無音]

00:02:32.891 --> 00:02:34.284
これをアイランドの探索ポイントと

00:02:34.284 --> 00:02:44.284
[無音]

00:02:45.453 --> 00:02:47.420
呼ぶことにして
ここで定義します

00:02:47.420 --> 00:02:47.920
なるほど

00:02:47.920 --> 00:02:57.920
[無音]

00:03:09.169 --> 00:03:12.211
次にキューの初期化を
しなければなりません

00:03:12.211 --> 00:03:16.685
[無音]

00:03:16.685 --> 00:03:19.330
&gt;&gt; キューを選んだのはなぜですか

00:03:19.330 --> 00:03:21.700
&gt;&gt; 幅優先探索を行っているので
配列にある最初の要素を

00:03:21.700 --> 00:03:27.570
取得するにはキューを
使うのが適切だからです

00:03:27.570 --> 00:03:29.620
キューに要素を追加する際には

00:03:29.620 --> 00:03:32.690
追加した最初の要素を取得する
必要があります

00:03:32.690 --> 00:03:36.400
&gt;&gt; 確かにそうですね

00:03:36.400 --> 00:03:38.429
&gt;&gt; このメソッドをインポート
しなければなりません

00:03:38.430 --> 00:03:40.478
これはコレクションフレームワークから取得しました

00:03:40.478 --> 00:03:42.914
[無音]

00:03:42.914 --> 00:03:43.712
&gt;&gt; いいですね

00:03:43.712 --> 00:03:53.712
[無音]

00:03:55.818 --> 00:03:58.657
&gt;&gt; 次にここにインデックスを追加して

00:03:58.657 --> 00:04:01.245
ロケーションがわかるようにします

00:04:01.245 --> 00:04:06.711
これらのインデックスをキューに固定します

00:04:06.711 --> 00:04:16.711
[無音]

00:04:18.390 --> 00:04:21.820
続いて、幅優先探索をするので

00:04:21.820 --> 00:04:26.683
これが空のままの状態で
周囲にある他の変数の値を探します

00:04:26.683 --> 00:04:29.724
[無音]

00:04:29.725 --> 00:04:31.490
キューの長さは

00:04:31.490 --> 00:04:36.658
[無音]

00:04:36.658 --> 00:04:38.629
0 と等しくないので

00:04:38.629 --> 00:04:45.160
[無音]

00:04:45.160 --> 00:04:50.520
この周囲にある要素を
調べてみます

00:04:50.520 --> 00:04:56.490
実際に要素があるかどうか確認する
必要があると仰っていましたよね

00:04:56.490 --> 00:04:58.438
そこでヘルパーメソッドを使って
確認したいと思います

00:04:58.438 --> 00:05:01.816
[無音]

00:05:01.816 --> 00:05:05.270
これが空かどうか
確認しているところなので

00:05:05.280 --> 00:05:08.180
この要素を使って
あることを実行します

00:05:08.180 --> 00:05:09.930
スペースがなくなってきたので
ここから移動して

00:05:09.930 --> 00:05:12.800
この部分を使って
記述することにします

00:05:13.850 --> 00:05:17.970
このセクションを切り離して
メソッドの残りの部分に

00:05:17.970 --> 00:05:19.229
取りかかりたいと思います

00:05:20.700 --> 00:05:24.750
この要素を取得する
必要があるのですが…

00:05:24.750 --> 00:05:29.400
スペースがなくなりそうなので
少し上から書きます

00:05:32.600 --> 00:05:34.136
この要素をキューから
削除します

00:05:34.136 --> 00:05:39.749
これら 2 つの変数に
アクセスする必要があるので

00:05:39.749 --> 00:05:44.280
これらの変数を
新しい式に設定します

00:05:44.280 --> 00:05:54.360
[無音]

00:05:54.360 --> 00:05:56.489
できました

00:05:56.489 --> 00:06:00.410
次にこの要素が 1 と等しいか
確認します

00:06:00.410 --> 00:06:10.960
[無音]

00:06:10.960 --> 00:06:13.416
等しい場合は、先ほど説明したように
2 に設定します

00:06:13.416 --> 00:06:21.420
[無音]

00:06:21.420 --> 00:06:26.630
ここでヘルパーメソッドを使用し
本当にこれらの要素が

00:06:26.630 --> 00:06:29.920
次に来るか
確認します

00:06:29.920 --> 00:06:34.220
もしそうであれば
キューに追加します

00:06:34.220 --> 00:06:36.599
このメソッドを…

00:06:36.599 --> 00:06:38.851
[無音]

00:06:38.851 --> 00:06:40.900
スペースがないのでこちらに移動します

00:06:40.900 --> 00:06:44.680
このメソッドを
append if と呼ぶことに

00:06:44.680 --> 00:06:48.507
[無音]

00:06:48.507 --> 00:06:49.700
します

00:06:50.630 --> 00:06:53.320
そしてキューを渡します

00:06:53.320 --> 00:06:54.441
それから

00:06:54.441 --> 00:06:57.568
[無音]

00:06:57.568 --> 00:07:01.159
行と列、これら両方の

00:07:01.160 --> 00:07:06.463
座標も必要です

00:07:06.463 --> 00:07:07.820
では

00:07:07.820 --> 00:07:13.356
次に x 値が 0 以上なのか

00:07:13.356 --> 00:07:18.431
あるいは

00:07:18.431 --> 00:07:20.320
すみません

00:07:20.320 --> 00:07:20.971
「また」の間違いです

00:07:20.971 --> 00:07:23.934
[無音]

00:07:23.934 --> 00:07:30.686
また、列の数よりも少ないか

00:07:30.686 --> 00:07:37.438
そして y は 0 以上の値なのか

00:07:37.438 --> 00:07:44.406
また、y は行の数よりも少ないのか
確認します

00:07:44.406 --> 00:07:48.735
これらの条件がすべて
真であれば

00:07:48.735 --> 00:07:54.300
これをキューに追加
することになります

00:07:54.300 --> 00:07:58.168
[無音]

00:07:58.168 --> 00:08:01.221
そして、これをここに追加します

00:08:01.221 --> 00:08:06.988
正しく追加しているか
確認するために

00:08:06.988 --> 00:08:12.500
最初の要素を
ここに挿入します

00:08:12.500 --> 00:08:14.280
これでうまくいきます

00:08:14.280 --> 00:08:16.900
ここの部分の記述と
ヘルパーメソッドを完了したので…

00:08:16.900 --> 00:08:18.969
またスペースがなくなりました

00:08:18.970 --> 00:08:22.531
ここにある情報は
周囲にあるすべての要素の

00:08:22.531 --> 00:08:23.698
呼び出しを行っていることを表しています

00:08:23.698 --> 00:08:27.897
そこで if を

00:08:27.898 --> 00:08:31.241
[無音]

00:08:31.241 --> 00:08:32.681
追加します

00:08:32.681 --> 00:08:33.885
そして
キューを渡します

00:08:33.885 --> 00:08:39.860
行、列、そして
x に 1 と y を足します

00:08:42.308 --> 00:08:45.170
右側の要素が
これになります

00:08:45.180 --> 00:08:48.682
[無音]

00:08:48.682 --> 00:08:52.629
そして、これが下に来る
要素になります

00:08:52.629 --> 00:09:01.793
[無音]

00:09:01.793 --> 00:09:03.100
なので、左と

00:09:03.100 --> 00:09:13.100
[無音]

00:09:19.790 --> 00:09:21.276
上になります

00:09:21.276 --> 00:09:22.780
このようになります

00:09:24.940 --> 00:09:27.110
なかなかスムーズな回答でしたね

00:09:27.110 --> 00:09:28.510
&gt;&gt; そうですね

00:09:28.510 --> 00:09:32.260
解をコーディングする前に必要な
ステップをすべて完了させておくと

00:09:32.260 --> 00:09:36.800
いきなり記述するよりも
ずっと簡単にコーディング

00:09:36.800 --> 00:09:37.770
できるようになります

00:09:37.770 --> 00:09:40.699
&gt;&gt; 面接を受けていたこの男性は
何を行っているのか説明しながら

00:09:40.700 --> 00:09:42.560
コーディングを進めていましたが

00:09:42.560 --> 00:09:45.810
すべてのコードを口に
出していたわけではありません

00:09:45.810 --> 00:09:49.550
面接では記述しているコードを
読み上げているだけの人をよく見かけますが

00:09:49.550 --> 00:09:52.859
これでは面接官を
納得させることができません

00:09:54.180 --> 00:09:54.900
&gt;&gt; そのとおり

00:09:54.900 --> 00:09:58.420
この面接では
記述しながら

00:09:58.420 --> 00:10:00.000
コードを読み上げていましたね

00:10:00.000 --> 00:10:03.630
コードを読み上げながら記述すると
間違った論理が展開されていても

00:10:03.630 --> 00:10:05.620
面接官に軌道修正してもらえる可能性があります

00:10:05.620 --> 00:10:08.400
また、この面接では
すべてのコードを実際に考えながら

00:10:08.400 --> 00:10:10.520
記述していることが伝わってきました

00:10:10.520 --> 00:10:13.490
単にコードを記述するだけでは丸暗記した
台詞に聞こえてしまいますよ

